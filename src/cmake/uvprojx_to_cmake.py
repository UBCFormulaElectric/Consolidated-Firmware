"""
This file contains all the functionality required to parse `.uvprojx` files for
the various projects and figure out what we need to build in for each project

This is normally called from `CMakeLists.txt`
"""

import xml.etree.cElementTree as ET
from optparse import OptionParser
import os


CMAKE_FILE_FORMAT = '''\
# AUTOGENERATED - DO NOT MODIFY - WILL BE OVERWRITTEN

# Clear the variables in case they've been set before
set(INCLUDE_DIRS)
set(SRC_C_FILES)

list(APPEND INCLUDE_DIRS {include_dirs})
set(SRC_C_FILES {src_c_files})
'''

"""
This class contains all the required functionality to parse out different parts
from ".uvprojx" files
"""
class UvprojxParser:

    """
    @param uvprojx_file A string holding the contents of an entire `.uvprojx` file
    """
    def __init__(self, uvprojx_file: str):
        self.uvprojx_file = uvprojx_file

    """
    Gets all the `.c` files used in this `.uvprojx` file
    @return a list of file paths to all the `.c` files
    """
    def get_c_file_paths(self) -> [str]:
        filepaths = []

        root = ET.fromstring(self.uvprojx_file)

        # We want the contents of every "<FilePath>" within a "<File>" which
        # also has a "<FileType>" of "1"

        # Find every "<File>.*</File>"
        file_tags = root.findall('.//File')
        for file_tag in file_tags:
            # Check the "<FileType>"
            if file_tag.find('FileType').text == "1":
                filepath = file_tag.find('FilePath')
                if filepath is not None:
                    filepath = self.__fix_file_path(filepath.text)
                    filepaths.append(filepath)

        return filepaths

    """
    Gets all the include directories in this ".uvprojx" file
    @return a list of directories that this ".uvprojx" file looks in for headers
    """
    def get_include_directories(self) -> [str]:
        include_dirs = []

        root = ET.fromstring(self.uvprojx_file)

        # We want the contents of every "<IncludePath>"

        # Find every "<IncludePath>.*</IncludePath>"
        include_dir_tags = root.findall('.//IncludePath')
        for include_dir_tag in include_dir_tags:
            # The normal string in the "<IncludeDir>" tags is a 
            # semicolon-seperated list of directory paths
            include_dirs_str = include_dir_tag.text
            if include_dirs_str is not None:
                for include_dir_path in include_dirs_str.split(';'):
                    include_dirs.append(self.__fix_file_path(include_dir_path))

        return include_dirs

    """
    Fixes up the file path so that it's consistent and sane
    @param the file path to fix
    @param the fixed file path
    """
    def __fix_file_path(self, path_to_fix: str) -> str:
        path_to_fix = os.path.normpath(path_to_fix)
        path_to_fix = path_to_fix.replace('\\', '/')
        path_to_fix = path_to_fix.strip(" ")
        return path_to_fix

    
class CMakeFileGenerator:

    def __init__(self, c_source_file_paths: [str], include_dirs: [str], 
            file_path_prefix: str) -> str:
        self.c_source_file_paths = c_source_file_paths
        self.include_dirs = include_dirs
        self.file_path_prefix = file_path_prefix

    """
    Prepares the given file path/prefix to be saved to a cmake file

    @param file_path_prefix A file path to be prefixed to the `file_path`
    @param file_path The file path to prepare
    """
    def __sanitize_file_path(self, file_path_prefix: str, file_path: str) -> str:
        return os.path.join(file_path_prefix, file_path).replace(" ", "\\ ")

    """
    Generates a cmake file based on the given arguments
    @param c_source_file_paths The paths to be placed in the ${SRC_C_FILES} variable
    in the generated cmake file
    @param include_dirs The paths to be placed in the ${INCLUDE_DIRS} variable
    in the generated cmake file
    @param file_path_prefix A prefix that is appended to that start of all paths
    @return A string that that represents the generated cmake file (ie. one that
    can be nicely written directly to a file)
    """
    def generate_cmake_file_str(self) -> str:
        # Cleanup the file paths
        c_source_file_paths = [self.__sanitize_file_path(self.file_path_prefix, path) 
                for path in self.c_source_file_paths]
        include_dirs = [self.__sanitize_file_path(self.file_path_prefix, path) 
                for path in self.include_dirs]

        # Properly quote the include directories
        include_dirs = ["\"{}\"".format(path) for path in include_dirs]

        # Create a single string for both the c source files and include dirs
        src_c_files_str = ";".join(c_source_file_paths)
        include_dirs_str = " ".join(include_dirs)

        return CMAKE_FILE_FORMAT.format(
                include_dirs=include_dirs_str,
                src_c_files=src_c_files_str,
                )


def main():
    # Parse options
    usage = "usage: %prog path/to/generated.cmake path/to/something.uvprojx"
    parser = OptionParser(usage=usage)
    parser.add_option("", "--file-path-prefix", dest="file_path_prefix",
            default="",
            help="the path given with this option will be prefixed to all \
                    paths placed in the generated cmake file")

    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error("incorrect number of arguments")

    # Read in the requested project file
    uvprojx_file_str = "";
    with open(args[1], 'r') as uvprojx_file:
        uvprojx_file_str = uvprojx_file.read()

    # Parse the requested project file
    uvprojx_parser = UvprojxParser(uvprojx_file_str)

    # Generate a cmake file from the project file
    cmake_file_str = CMakeFileGenerator(
            uvprojx_parser.get_c_file_paths(),
            uvprojx_parser.get_include_directories(),
            options.file_path_prefix,
            ).generate_cmake_file_str()

    # Write the cmake file out to the requested filepath
    with open(args[0], 'w') as f:
        f.write(cmake_file_str)


if __name__ == "__main__":
    main()

