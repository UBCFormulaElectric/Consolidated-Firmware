import xml.etree.cElementTree as ET
from optparse import OptionParser
import os

"""
This class contains all the required functionality to parse out different part 
"""
class UvprojxParser:

    """
    @param uvprojx_file A string holding the contents of an entire `.uvprojx` file
    """
    def __init__(self, uvprojx_file: str):
        self.uvprojx_file = uvprojx_file

    """
    Gets all the `.c` files used in this `.uvprojx` file
    @return a list of file paths to all the `.c` files
    """
    def get_c_file_paths(self) -> [str]:
        filepaths = []

        root = ET.fromstring(self.uvprojx_file)

        # We want the contents of every "<FilePath>" within a "<File>" which
        # also has a "<FileType>" of "1"

        # Find every "<File>.*</File>"
        file_tags = root.findall('.//File')
        for file_tag in file_tags:
            # Check the "<FileType>"
            if file_tag.find('FileType').text == "1":
                filepath = file_tag.find('FilePath')
                if filepath is not None:
                    filepath = self.__fix_file_path(filepath.text)
                    filepaths.append(filepath)

        return filepaths

    """
    Gets all the include directories in this ".uvprojx" file
    @return a list of directories that this ".uvprojx" file looks in for headers
    """
    def get_include_directories(self) -> [str]:
        include_dirs = []

        root = ET.fromstring(self.uvprojx_file)

        # We want the contents of every "<IncludePath>"

        # Find every "<IncludePath>.*</IncludePath>"
        include_dir_tags = root.findall('.//IncludePath')
        for include_dir_tag in include_dir_tags:
            # The normal string in the "<IncludeDir>" tags is a 
            # semicolon-seperated list of directory paths
            include_dirs_str = include_dir_tag.text
            if include_dirs_str is not None:
                for include_dir_path in include_dirs_str.split(';'):
                    include_dirs.append(self.__fix_file_path(include_dir_path))

        return include_dirs

    """
    Fixes up the file path so that it's consistent and sane
    @param the file path to fix
    @param the fixed file path
    """
    def __fix_file_path(self, path_to_fix: str) -> str:
        path_to_fix = os.path.normpath(path_to_fix)
        path_to_fix = path_to_fix.replace('\\', '/')
        path_to_fix = path_to_fix.strip(" ")
        return path_to_fix


"""
Generates a cmake file based on the given arguments
@param c_source_file_paths The paths to be placed in the ${SRC_C_FILES} variable
in the generated cmake file
@param include_dirs The paths to be placed in the ${INCLUDE_DIRS} variable
in the generated cmake file
@param file_path_prefix A prefix that is appended to that start of all paths
@return A string that that represents the generated cmake file (ie. one that
can be nicely written directly to a file)
"""
def generate_cmake_file_str(c_source_file_paths: [str], include_dirs: [str], 
        file_path_prefix: str) -> str:
    c_source_file_paths = [os.path.join(file_path_prefix, file_path) 
            for file_path in c_source_file_paths]
    include_dirs = ["\"{}\"".format(os.path.join(file_path_prefix, file_path)) 
            for file_path in include_dirs]

    src_c_files_str = ";".join(c_source_file_paths)
    include_dirs_str = " ".join(include_dirs)

    # NOTE: the wierd indenting here is because any spaces before the text
    #       are reflected in the generated file
    CMAKE_FILE_FORMAT = '''\
# AUTOGENERATED - DO NOT MODIFY - WILL BE OVERWRITTEN

# Clear the variables in case they've been set before
set(INCLUDE_DIRS)
set(SRC_C_FILES)

list(APPEND INCLUDE_DIRS {include_dirs})
set(SRC_C_FILES {src_c_files})
            '''
    return CMAKE_FILE_FORMAT.format(
            include_dirs=include_dirs_str,
            src_c_files=src_c_files_str,
            )


def main():
    # Parse options
    usage = "usage: %prog path/to/generated.cmake path/to/something.uvprojx"
    parser = OptionParser(usage=usage)
    parser.add_option("", "--file-path-prefix", dest="file_path_prefix",
            default="",
            help="the path given with this option will be prefixed to all \
                    paths placed in the generated cmake file")

    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error("incorrect number of arguments")

    # Read in the requested project file
    uvprojx_file_str = "";
    with open(args[1], 'r') as uvprojx_file:
        uvprojx_file_str = uvprojx_file.read()

    # Parse the requested project file
    uvprojx_parser = UvprojxParser(uvprojx_file_str)

    # Generate a cmake file from the project file
    cmake_file_str = generate_cmake_file_str(
            uvprojx_parser.get_c_file_paths(),
            uvprojx_parser.get_include_directories(),
            options.file_path_prefix,
            )

    # Write the cmake file out to the requested filepath
    with open(args[0], 'w') as f:
        f.write(cmake_file_str)


if __name__ == "__main__":
    main()

