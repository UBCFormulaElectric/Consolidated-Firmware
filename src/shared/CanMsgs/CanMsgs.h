/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.3.0 Tue Jan  8 22:21:39 2019.
 */

#ifndef CANMSGS_H
#define CANMSGS_H

#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

#ifndef EINVAL
#    define EINVAL -22
#endif

#define CANMSGS_BMS_ERROR_FRAME_ID (0x00u)
#define CANMSGS_BMS_HEARTBEAT_FRAME_ID (0x01u)
#define CANMSGS_BMS_CAN_TX_FIFO_OVERFLOW_FRAME_ID (0x02u)
#define CANMSGS_BMS_STARTUP_FRAME_ID (0x03u)
#define CANMSGS_BMS_RESERVED2_FRAME_ID (0x04u)
#define CANMSGS_BMS_RESERVED3_FRAME_ID (0x05u)
#define CANMSGS_BMS_ACCUMULATOR_STATUS_FRAME_ID (0x06u)
#define CANMSGS_BMS_DISCHARGE_POWER_LIMIT_FRAME_ID (0x07u)
#define CANMSGS_BMS_REGEN_POWER_LIMIT_FRAME_ID (0x08u)
#define CANMSGS_BMS_STATE_OF_CHARGE_FRAME_ID (0x09u)
#define CANMSGS_BMS_TURN_ON_ALL_FETS_FRAME_ID (0x00u)
#define CANMSGS_BMS_CELL_VOLTAGE_CAN_FRAME_ID (0x00u)
#define CANMSGS_BMS_BALANCE_MOSFET_FRAME_ID (0x00u)
#define CANMSGS_BMS_LATCH_RESET_FRAME_ID (0x00u)
#define CANMSGS_BMS_MOTOR_REENABLE_FRAME_ID (0x00u)
#define CANMSGS_BMS_AIR_SHUTDOWN_ERROR_FRAME_ID (0x00u)
#define CANMSGS_DCM_ERROR_FRAME_ID (0x20u)
#define CANMSGS_DCM_HEARTBEAT_FRAME_ID (0x21u)
#define CANMSGS_DCM_CAN_TX_FIFO_OVERFLOW_FRAME_ID (0x22u)
#define CANMSGS_DCM_STARTUP_FRAME_ID (0x23u)
#define CANMSGS_DCM_RESERVED2_FRAME_ID (0x24u)
#define CANMSGS_DCM_RESERVED3_FRAME_ID (0x25u)
#define CANMSGS_DCM_LEFT_SLIP_RATIO_FRAME_ID (0x26u)
#define CANMSGS_DCM_RIGHT_SLIP_RATIO_FRAME_ID (0x27u)
#define CANMSGS_DCM_LEFT_MOTOR_OUTPUT_FRAME_ID (0x28u)
#define CANMSGS_DCM_RIGHT_MOTOR_OUTPUT_FRAME_ID (0x29u)
#define CANMSGS_DCM_LEFT_SLIP_ERROR_FRAME_ID (0x02u)
#define CANMSGS_DCM_RIGHT_SLIP_ERROR_FRAME_ID (0x02u)
#define CANMSGS_FSM_ERROR_FRAME_ID (0x40u)
#define CANMSGS_FSM_HEARTBEAT_FRAME_ID (0x41u)
#define CANMSGS_FSM_CAN_TX_FIFO_OVERFLOW_FRAME_ID (0x42u)
#define CANMSGS_FSM_STARTUP_FRAME_ID (0x43u)
#define CANMSGS_FSM_RESERVED2_FRAME_ID (0x44u)
#define CANMSGS_FSM_RESERVED3_FRAME_ID (0x45u)
#define CANMSGS_FSM_BRAKE_APPS_FRAME_ID (0x46u)
#define CANMSGS_FSM_STEERING_ANGLE_FRAME_ID (0x47u)
#define CANMSGS_FSM_LEFT_WHEEL_SPEED_FRAME_ID (0x48u)
#define CANMSGS_FSM_RIGHT_WHEEL_SPEED_FRAME_ID (0x49u)
#define CANMSGS_PDM_ERROR_FRAME_ID (0x60u)
#define CANMSGS_PDM_HEARTBEAT_FRAME_ID (0x61u)
#define CANMSGS_PDM_CAN_TX_FIFO_OVERFLOW_FRAME_ID (0x62u)
#define CANMSGS_PDM_STARTUP_FRAME_ID (0x63u)
#define CANMSGS_PDM_RESERVED2_FRAME_ID (0x64u)
#define CANMSGS_PDM_RESERVED3_FRAME_ID (0x65u)
#define CANMSGS_SHARED_MOTOR_SHUTDOWN_ERROR_FRAME_ID (0x80u)
#define CANMSGS_LEFT_TORQUE_REQUEST_TX_FRAME_ID (0x190u)
#define CANMSGS_RIGHT_TORQUE_REQUEST_TX_FRAME_ID (0x191u)
#define CANMSGS_LEFT_TORQUE_REQUEST_RX_FRAME_ID (0x210u)
#define CANMSGS_RIGHT_TORQUE_REQUEST_RX_FRAME_ID (0x211u)
#define CANMSGS_DEMO_TOGGLE_GPIO1_FRAME_ID (0x400u)
#define CANMSGS_DEMO_TOGGLE_GPIO2_FRAME_ID (0x401u)
#define CANMSGS_DEMO_2_FLOAT_NUCLEO_TX_FRAME_ID (0x402u)
#define CANMSGS_DEMO_2_FLOAT_NUCLEO_RX_FRAME_ID (0x403u)
#define CANMSGS_DEMO_2_UINT32_NUCLEO_TX_FRAME_ID (0x404u)
#define CANMSGS_DEMO_2_UINT32_NUCLEO_RX_FRAME_ID (0x405u)
#define CANMSGS_DEMO_4_UINT16_NUCLEO_TX_FRAME_ID (0x406u)
#define CANMSGS_DEMO_4_UINT16_NUCLEO_RX_FRAME_ID (0x407u)
#define CANMSGS_DEMO_8_UINT8_NUCLEO_TX_FRAME_ID (0x408u)
#define CANMSGS_DEMO_8_UINT8_NUCLEO_RX_FRAME_ID (0x409u)
#define CANMSGS_DEMO_2_INT32_NUCLEO_TX_FRAME_ID (0x40u)
#define CANMSGS_DEMO_2_INT32_NUCLEO_RX_FRAME_ID (0x40u)

/**
 * Signals in message BMS_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message BMS_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message BMS_CAN_TX_FIFO_OVERFLOW.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_can_tx_fifo_overflow_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message BMS_STARTUP.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_startup_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message BMS_RESERVED2.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_reserved2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message BMS_RESERVED3.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_reserved3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message BMS_ACCUMULATOR_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_accumulator_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_3_byte;
};

/**
 * Signals in message BMS_DISCHARGE_POWER_LIMIT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_discharge_power_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message BMS_REGEN_POWER_LIMIT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_regen_power_limit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message BMS_STATE_OF_CHARGE.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_state_of_charge_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message BMS_TURN_ON_ALL_FETS.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_turn_on_all_fets_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message BMS_CELL_VOLTAGE_CAN.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_cell_voltage_can_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message BMS_BALANCE_MOSFET.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_balance_mosfet_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_5_byte;
};

/**
 * Signals in message BMS_LATCH_RESET.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_latch_reset_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message BMS_MOTOR_REENABLE.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_motor_reenable_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message BMS_AIR_SHUTDOWN_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_bms_air_shutdown_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_6_byte;
};

/**
 * Signals in message DCM_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message DCM_CAN_TX_FIFO_OVERFLOW.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_can_tx_fifo_overflow_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_STARTUP.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_startup_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message DCM_RESERVED2.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_reserved2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message DCM_RESERVED3.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_reserved3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message DCM_LEFT_SLIP_RATIO.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_left_slip_ratio_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_RIGHT_SLIP_RATIO.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_right_slip_ratio_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_LEFT_MOTOR_OUTPUT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_left_motor_output_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_RIGHT_MOTOR_OUTPUT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_right_motor_output_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_LEFT_SLIP_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_left_slip_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message DCM_RIGHT_SLIP_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_dcm_right_slip_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message FSM_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message FSM_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message FSM_CAN_TX_FIFO_OVERFLOW.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_can_tx_fifo_overflow_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message FSM_STARTUP.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_startup_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message FSM_RESERVED2.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_reserved2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message FSM_RESERVED3.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_reserved3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message FSM_BRAKE_APPS.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_brake_apps_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message FSM_STEERING_ANGLE.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_steering_angle_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message FSM_LEFT_WHEEL_SPEED.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_left_wheel_speed_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message FSM_RIGHT_WHEEL_SPEED.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_fsm_right_wheel_speed_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message PDM_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_pdm_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message PDM_HEARTBEAT.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_pdm_heartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message PDM_CAN_TX_FIFO_OVERFLOW.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_pdm_can_tx_fifo_overflow_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_4_byte;
};

/**
 * Signals in message PDM_STARTUP.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_pdm_startup_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message PDM_RESERVED2.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_pdm_reserved2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message PDM_RESERVED3.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_pdm_reserved3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_8_byte;
};

/**
 * Signals in message SHARED_MOTOR_SHUTDOWN_ERROR.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_shared_motor_shutdown_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t signal_6_byte;
};

/**
 * Signals in message LEFT_TORQUE_REQUEST_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_left_torque_request_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_3_byte;
};

/**
 * Signals in message RIGHT_TORQUE_REQUEST_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_right_torque_request_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_3_byte;
};

/**
 * Signals in message LEFT_TORQUE_REQUEST_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_left_torque_request_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_3_byte;
};

/**
 * Signals in message RIGHT_TORQUE_REQUEST_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_right_torque_request_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_3_byte;
};

/**
 * Signals in message DEMO_TOGGLE_GPIO1.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_toggle_gpio1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message DEMO_TOGGLE_GPIO2.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_toggle_gpio2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_1_byte;
};

/**
 * Signals in message DEMO_2_FLOAT_NUCLEO_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_2_float_nucleo_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float signal_float_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float signal_float_2;
};

/**
 * Signals in message DEMO_2_FLOAT_NUCLEO_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_2_float_nucleo_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float signal_float_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float signal_float_2;
};

/**
 * Signals in message DEMO_2_UINT32_NUCLEO_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_2_uint32_nucleo_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_unit32_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_unit32_2;
};

/**
 * Signals in message DEMO_2_UINT32_NUCLEO_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_2_uint32_nucleo_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_unit32_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_unit32_2;
};

/**
 * Signals in message DEMO_4_UINT16_NUCLEO_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_4_uint16_nucleo_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_4;
};

/**
 * Signals in message DEMO_4_UINT16_NUCLEO_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_4_uint16_nucleo_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t signal_unit16_4;
};

/**
 * Signals in message DEMO_8_UINT8_NUCLEO_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_8_uint8_nucleo_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_8;
};

/**
 * Signals in message DEMO_8_UINT8_NUCLEO_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_8_uint8_nucleo_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_unit8_8;
};

/**
 * Signals in message DEMO_2_INT32_NUCLEO_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_2_int32_nucleo_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t signal_int32_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_int32_2;
};

/**
 * Signals in message DEMO_2_INT32_NUCLEO_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct CanMsgs_demo_2_int32_nucleo_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t signal_int32_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t signal_int32_2;
};

/**
 * Pack message BMS_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_error_t *src_p,
    size_t size);

/**
 * Unpack message BMS_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_error_unpack(
    struct CanMsgs_bms_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_error_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_error_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_error_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_heartbeat_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message BMS_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_heartbeat_unpack(
    struct CanMsgs_bms_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_bms_heartbeat_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_heartbeat_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_heartbeat_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message BMS_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_can_tx_fifo_overflow_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_can_tx_fifo_overflow_t *src_p,
    size_t size);

/**
 * Unpack message BMS_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_can_tx_fifo_overflow_unpack(
    struct CanMsgs_bms_can_tx_fifo_overflow_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_can_tx_fifo_overflow_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_can_tx_fifo_overflow_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_can_tx_fifo_overflow_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_STARTUP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_startup_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_startup_t *src_p,
    size_t size);

/**
 * Unpack message BMS_STARTUP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_startup_unpack(
    struct CanMsgs_bms_startup_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_bms_startup_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_startup_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_startup_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message BMS_RESERVED2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_reserved2_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_reserved2_t *src_p,
    size_t size);

/**
 * Unpack message BMS_RESERVED2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_reserved2_unpack(
    struct CanMsgs_bms_reserved2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_bms_reserved2_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_reserved2_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_reserved2_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message BMS_RESERVED3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_reserved3_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_reserved3_t *src_p,
    size_t size);

/**
 * Unpack message BMS_RESERVED3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_reserved3_unpack(
    struct CanMsgs_bms_reserved3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_bms_reserved3_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_reserved3_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_reserved3_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message BMS_ACCUMULATOR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_accumulator_status_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_accumulator_status_t *src_p,
    size_t size);

/**
 * Unpack message BMS_ACCUMULATOR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_accumulator_status_unpack(
    struct CanMsgs_bms_accumulator_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_accumulator_status_signal_3_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_accumulator_status_signal_3_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_accumulator_status_signal_3_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_DISCHARGE_POWER_LIMIT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_discharge_power_limit_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_discharge_power_limit_t *src_p,
    size_t size);

/**
 * Unpack message BMS_DISCHARGE_POWER_LIMIT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_discharge_power_limit_unpack(
    struct CanMsgs_bms_discharge_power_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_discharge_power_limit_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_discharge_power_limit_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_discharge_power_limit_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_REGEN_POWER_LIMIT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_regen_power_limit_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_regen_power_limit_t *src_p,
    size_t size);

/**
 * Unpack message BMS_REGEN_POWER_LIMIT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_regen_power_limit_unpack(
    struct CanMsgs_bms_regen_power_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_regen_power_limit_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_regen_power_limit_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_regen_power_limit_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_STATE_OF_CHARGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_state_of_charge_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_state_of_charge_t *src_p,
    size_t size);

/**
 * Unpack message BMS_STATE_OF_CHARGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_state_of_charge_unpack(
    struct CanMsgs_bms_state_of_charge_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_state_of_charge_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_state_of_charge_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_state_of_charge_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_TURN_ON_ALL_FETS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_turn_on_all_fets_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_turn_on_all_fets_t *src_p,
    size_t size);

/**
 * Unpack message BMS_TURN_ON_ALL_FETS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_turn_on_all_fets_unpack(
    struct CanMsgs_bms_turn_on_all_fets_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_bms_turn_on_all_fets_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_turn_on_all_fets_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_turn_on_all_fets_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message BMS_CELL_VOLTAGE_CAN.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_cell_voltage_can_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_cell_voltage_can_t *src_p,
    size_t size);

/**
 * Unpack message BMS_CELL_VOLTAGE_CAN.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_cell_voltage_can_unpack(
    struct CanMsgs_bms_cell_voltage_can_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_bms_cell_voltage_can_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_cell_voltage_can_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_cell_voltage_can_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message BMS_BALANCE_MOSFET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_balance_mosfet_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_balance_mosfet_t *src_p,
    size_t size);

/**
 * Unpack message BMS_BALANCE_MOSFET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_balance_mosfet_unpack(
    struct CanMsgs_bms_balance_mosfet_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_bms_balance_mosfet_signal_5_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_balance_mosfet_signal_5_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_balance_mosfet_signal_5_byte_is_in_range(uint64_t value);

/**
 * Pack message BMS_LATCH_RESET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_latch_reset_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_latch_reset_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LATCH_RESET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_latch_reset_unpack(
    struct CanMsgs_bms_latch_reset_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_bms_latch_reset_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_latch_reset_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_latch_reset_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message BMS_MOTOR_REENABLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_motor_reenable_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_motor_reenable_t *src_p,
    size_t size);

/**
 * Unpack message BMS_MOTOR_REENABLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_motor_reenable_unpack(
    struct CanMsgs_bms_motor_reenable_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_bms_motor_reenable_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_motor_reenable_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_motor_reenable_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message BMS_AIR_SHUTDOWN_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_bms_air_shutdown_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_bms_air_shutdown_error_t *src_p,
    size_t size);

/**
 * Unpack message BMS_AIR_SHUTDOWN_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_bms_air_shutdown_error_unpack(
    struct CanMsgs_bms_air_shutdown_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_bms_air_shutdown_error_signal_6_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_bms_air_shutdown_error_signal_6_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_bms_air_shutdown_error_signal_6_byte_is_in_range(uint64_t value);

/**
 * Pack message DCM_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_error_t *src_p,
    size_t size);

/**
 * Unpack message DCM_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_error_unpack(
    struct CanMsgs_dcm_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_error_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_error_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_error_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_heartbeat_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message DCM_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_heartbeat_unpack(
    struct CanMsgs_dcm_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_dcm_heartbeat_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_heartbeat_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_heartbeat_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message DCM_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_can_tx_fifo_overflow_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_can_tx_fifo_overflow_t *src_p,
    size_t size);

/**
 * Unpack message DCM_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_can_tx_fifo_overflow_unpack(
    struct CanMsgs_dcm_can_tx_fifo_overflow_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_can_tx_fifo_overflow_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_can_tx_fifo_overflow_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_can_tx_fifo_overflow_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_STARTUP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_startup_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_startup_t *src_p,
    size_t size);

/**
 * Unpack message DCM_STARTUP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_startup_unpack(
    struct CanMsgs_dcm_startup_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_dcm_startup_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_startup_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_startup_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message DCM_RESERVED2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_reserved2_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_reserved2_t *src_p,
    size_t size);

/**
 * Unpack message DCM_RESERVED2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_reserved2_unpack(
    struct CanMsgs_dcm_reserved2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_dcm_reserved2_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_reserved2_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_reserved2_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message DCM_RESERVED3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_reserved3_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_reserved3_t *src_p,
    size_t size);

/**
 * Unpack message DCM_RESERVED3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_reserved3_unpack(
    struct CanMsgs_dcm_reserved3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_dcm_reserved3_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_reserved3_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_reserved3_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message DCM_LEFT_SLIP_RATIO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_left_slip_ratio_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_left_slip_ratio_t *src_p,
    size_t size);

/**
 * Unpack message DCM_LEFT_SLIP_RATIO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_left_slip_ratio_unpack(
    struct CanMsgs_dcm_left_slip_ratio_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_left_slip_ratio_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_left_slip_ratio_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_left_slip_ratio_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_RIGHT_SLIP_RATIO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_right_slip_ratio_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_right_slip_ratio_t *src_p,
    size_t size);

/**
 * Unpack message DCM_RIGHT_SLIP_RATIO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_right_slip_ratio_unpack(
    struct CanMsgs_dcm_right_slip_ratio_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_right_slip_ratio_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_right_slip_ratio_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_right_slip_ratio_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_LEFT_MOTOR_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_left_motor_output_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_left_motor_output_t *src_p,
    size_t size);

/**
 * Unpack message DCM_LEFT_MOTOR_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_left_motor_output_unpack(
    struct CanMsgs_dcm_left_motor_output_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_left_motor_output_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_left_motor_output_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_left_motor_output_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_RIGHT_MOTOR_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_right_motor_output_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_right_motor_output_t *src_p,
    size_t size);

/**
 * Unpack message DCM_RIGHT_MOTOR_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_right_motor_output_unpack(
    struct CanMsgs_dcm_right_motor_output_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_right_motor_output_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_right_motor_output_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_right_motor_output_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_LEFT_SLIP_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_left_slip_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_left_slip_error_t *src_p,
    size_t size);

/**
 * Unpack message DCM_LEFT_SLIP_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_left_slip_error_unpack(
    struct CanMsgs_dcm_left_slip_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_left_slip_error_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_left_slip_error_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_left_slip_error_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message DCM_RIGHT_SLIP_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_dcm_right_slip_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_dcm_right_slip_error_t *src_p,
    size_t size);

/**
 * Unpack message DCM_RIGHT_SLIP_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_dcm_right_slip_error_unpack(
    struct CanMsgs_dcm_right_slip_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_dcm_right_slip_error_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_dcm_right_slip_error_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_dcm_right_slip_error_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message FSM_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_error_t *src_p,
    size_t size);

/**
 * Unpack message FSM_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_error_unpack(
    struct CanMsgs_fsm_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_fsm_error_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_error_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_error_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message FSM_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_heartbeat_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message FSM_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_heartbeat_unpack(
    struct CanMsgs_fsm_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_fsm_heartbeat_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_heartbeat_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_heartbeat_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message FSM_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_can_tx_fifo_overflow_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_can_tx_fifo_overflow_t *src_p,
    size_t size);

/**
 * Unpack message FSM_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_can_tx_fifo_overflow_unpack(
    struct CanMsgs_fsm_can_tx_fifo_overflow_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_fsm_can_tx_fifo_overflow_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_can_tx_fifo_overflow_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_can_tx_fifo_overflow_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message FSM_STARTUP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_startup_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_startup_t *src_p,
    size_t size);

/**
 * Unpack message FSM_STARTUP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_startup_unpack(
    struct CanMsgs_fsm_startup_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_fsm_startup_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_startup_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_startup_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message FSM_RESERVED2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_reserved2_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_reserved2_t *src_p,
    size_t size);

/**
 * Unpack message FSM_RESERVED2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_reserved2_unpack(
    struct CanMsgs_fsm_reserved2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_fsm_reserved2_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_reserved2_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_reserved2_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message FSM_RESERVED3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_reserved3_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_reserved3_t *src_p,
    size_t size);

/**
 * Unpack message FSM_RESERVED3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_reserved3_unpack(
    struct CanMsgs_fsm_reserved3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_fsm_reserved3_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_reserved3_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_reserved3_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message FSM_BRAKE_APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_brake_apps_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_brake_apps_t *src_p,
    size_t size);

/**
 * Unpack message FSM_BRAKE_APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_brake_apps_unpack(
    struct CanMsgs_fsm_brake_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_fsm_brake_apps_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_brake_apps_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_brake_apps_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message FSM_STEERING_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_steering_angle_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_steering_angle_t *src_p,
    size_t size);

/**
 * Unpack message FSM_STEERING_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_steering_angle_unpack(
    struct CanMsgs_fsm_steering_angle_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_fsm_steering_angle_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_steering_angle_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_steering_angle_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message FSM_LEFT_WHEEL_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_left_wheel_speed_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_left_wheel_speed_t *src_p,
    size_t size);

/**
 * Unpack message FSM_LEFT_WHEEL_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_left_wheel_speed_unpack(
    struct CanMsgs_fsm_left_wheel_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_fsm_left_wheel_speed_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_left_wheel_speed_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_left_wheel_speed_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message FSM_RIGHT_WHEEL_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_fsm_right_wheel_speed_pack(
    uint8_t *dst_p,
    const struct CanMsgs_fsm_right_wheel_speed_t *src_p,
    size_t size);

/**
 * Unpack message FSM_RIGHT_WHEEL_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_fsm_right_wheel_speed_unpack(
    struct CanMsgs_fsm_right_wheel_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_fsm_right_wheel_speed_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_fsm_right_wheel_speed_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_fsm_right_wheel_speed_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message PDM_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_pdm_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_pdm_error_t *src_p,
    size_t size);

/**
 * Unpack message PDM_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_pdm_error_unpack(
    struct CanMsgs_pdm_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_pdm_error_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_pdm_error_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_pdm_error_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message PDM_HEARTBEAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_pdm_heartbeat_pack(
    uint8_t *dst_p,
    const struct CanMsgs_pdm_heartbeat_t *src_p,
    size_t size);

/**
 * Unpack message PDM_HEARTBEAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_pdm_heartbeat_unpack(
    struct CanMsgs_pdm_heartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_pdm_heartbeat_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_pdm_heartbeat_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_pdm_heartbeat_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message PDM_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_pdm_can_tx_fifo_overflow_pack(
    uint8_t *dst_p,
    const struct CanMsgs_pdm_can_tx_fifo_overflow_t *src_p,
    size_t size);

/**
 * Unpack message PDM_CAN_TX_FIFO_OVERFLOW.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_pdm_can_tx_fifo_overflow_unpack(
    struct CanMsgs_pdm_can_tx_fifo_overflow_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_pdm_can_tx_fifo_overflow_signal_4_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_pdm_can_tx_fifo_overflow_signal_4_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_pdm_can_tx_fifo_overflow_signal_4_byte_is_in_range(uint32_t value);

/**
 * Pack message PDM_STARTUP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_pdm_startup_pack(
    uint8_t *dst_p,
    const struct CanMsgs_pdm_startup_t *src_p,
    size_t size);

/**
 * Unpack message PDM_STARTUP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_pdm_startup_unpack(
    struct CanMsgs_pdm_startup_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_pdm_startup_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_pdm_startup_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_pdm_startup_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message PDM_RESERVED2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_pdm_reserved2_pack(
    uint8_t *dst_p,
    const struct CanMsgs_pdm_reserved2_t *src_p,
    size_t size);

/**
 * Unpack message PDM_RESERVED2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_pdm_reserved2_unpack(
    struct CanMsgs_pdm_reserved2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_pdm_reserved2_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_pdm_reserved2_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_pdm_reserved2_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message PDM_RESERVED3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_pdm_reserved3_pack(
    uint8_t *dst_p,
    const struct CanMsgs_pdm_reserved3_t *src_p,
    size_t size);

/**
 * Unpack message PDM_RESERVED3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_pdm_reserved3_unpack(
    struct CanMsgs_pdm_reserved3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_pdm_reserved3_signal_8_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_pdm_reserved3_signal_8_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_pdm_reserved3_signal_8_byte_is_in_range(uint64_t value);

/**
 * Pack message SHARED_MOTOR_SHUTDOWN_ERROR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_shared_motor_shutdown_error_pack(
    uint8_t *dst_p,
    const struct CanMsgs_shared_motor_shutdown_error_t *src_p,
    size_t size);

/**
 * Unpack message SHARED_MOTOR_SHUTDOWN_ERROR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_shared_motor_shutdown_error_unpack(
    struct CanMsgs_shared_motor_shutdown_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t CanMsgs_shared_motor_shutdown_error_signal_6_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_shared_motor_shutdown_error_signal_6_byte_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_shared_motor_shutdown_error_signal_6_byte_is_in_range(uint64_t value);

/**
 * Pack message LEFT_TORQUE_REQUEST_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_left_torque_request_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_left_torque_request_tx_t *src_p,
    size_t size);

/**
 * Unpack message LEFT_TORQUE_REQUEST_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_left_torque_request_tx_unpack(
    struct CanMsgs_left_torque_request_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_left_torque_request_tx_signal_3_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_left_torque_request_tx_signal_3_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_left_torque_request_tx_signal_3_byte_is_in_range(uint32_t value);

/**
 * Pack message RIGHT_TORQUE_REQUEST_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_right_torque_request_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_right_torque_request_tx_t *src_p,
    size_t size);

/**
 * Unpack message RIGHT_TORQUE_REQUEST_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_right_torque_request_tx_unpack(
    struct CanMsgs_right_torque_request_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_right_torque_request_tx_signal_3_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_right_torque_request_tx_signal_3_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_right_torque_request_tx_signal_3_byte_is_in_range(uint32_t value);

/**
 * Pack message LEFT_TORQUE_REQUEST_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_left_torque_request_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_left_torque_request_rx_t *src_p,
    size_t size);

/**
 * Unpack message LEFT_TORQUE_REQUEST_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_left_torque_request_rx_unpack(
    struct CanMsgs_left_torque_request_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_left_torque_request_rx_signal_3_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_left_torque_request_rx_signal_3_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_left_torque_request_rx_signal_3_byte_is_in_range(uint32_t value);

/**
 * Pack message RIGHT_TORQUE_REQUEST_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_right_torque_request_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_right_torque_request_rx_t *src_p,
    size_t size);

/**
 * Unpack message RIGHT_TORQUE_REQUEST_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_right_torque_request_rx_unpack(
    struct CanMsgs_right_torque_request_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_right_torque_request_rx_signal_3_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_right_torque_request_rx_signal_3_byte_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_right_torque_request_rx_signal_3_byte_is_in_range(uint32_t value);

/**
 * Pack message DEMO_TOGGLE_GPIO1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_toggle_gpio1_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_toggle_gpio1_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_TOGGLE_GPIO1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_toggle_gpio1_unpack(
    struct CanMsgs_demo_toggle_gpio1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_toggle_gpio1_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_toggle_gpio1_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_toggle_gpio1_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message DEMO_TOGGLE_GPIO2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_toggle_gpio2_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_toggle_gpio2_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_TOGGLE_GPIO2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_toggle_gpio2_unpack(
    struct CanMsgs_demo_toggle_gpio2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_toggle_gpio2_signal_1_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_toggle_gpio2_signal_1_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_toggle_gpio2_signal_1_byte_is_in_range(uint8_t value);

/**
 * Pack message DEMO_2_FLOAT_NUCLEO_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_2_float_nucleo_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_2_float_nucleo_tx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_2_FLOAT_NUCLEO_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_2_float_nucleo_tx_unpack(
    struct CanMsgs_demo_2_float_nucleo_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float CanMsgs_demo_2_float_nucleo_tx_signal_float_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_float_nucleo_tx_signal_float_1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_float_nucleo_tx_signal_float_1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float CanMsgs_demo_2_float_nucleo_tx_signal_float_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_float_nucleo_tx_signal_float_2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_float_nucleo_tx_signal_float_2_is_in_range(float value);

/**
 * Pack message DEMO_2_FLOAT_NUCLEO_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_2_float_nucleo_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_2_float_nucleo_rx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_2_FLOAT_NUCLEO_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_2_float_nucleo_rx_unpack(
    struct CanMsgs_demo_2_float_nucleo_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float CanMsgs_demo_2_float_nucleo_rx_signal_float_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_float_nucleo_rx_signal_float_1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_float_nucleo_rx_signal_float_1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float CanMsgs_demo_2_float_nucleo_rx_signal_float_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_float_nucleo_rx_signal_float_2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_float_nucleo_rx_signal_float_2_is_in_range(float value);

/**
 * Pack message DEMO_2_UINT32_NUCLEO_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_2_uint32_nucleo_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_2_uint32_nucleo_tx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_2_UINT32_NUCLEO_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_2_uint32_nucleo_tx_unpack(
    struct CanMsgs_demo_2_uint32_nucleo_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_demo_2_uint32_nucleo_tx_signal_unit32_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_uint32_nucleo_tx_signal_unit32_1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_uint32_nucleo_tx_signal_unit32_1_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_demo_2_uint32_nucleo_tx_signal_unit32_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_uint32_nucleo_tx_signal_unit32_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_uint32_nucleo_tx_signal_unit32_2_is_in_range(uint32_t value);

/**
 * Pack message DEMO_2_UINT32_NUCLEO_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_2_uint32_nucleo_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_2_uint32_nucleo_rx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_2_UINT32_NUCLEO_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_2_uint32_nucleo_rx_unpack(
    struct CanMsgs_demo_2_uint32_nucleo_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_demo_2_uint32_nucleo_rx_signal_unit32_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_uint32_nucleo_rx_signal_unit32_1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_uint32_nucleo_rx_signal_unit32_1_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_demo_2_uint32_nucleo_rx_signal_unit32_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_uint32_nucleo_rx_signal_unit32_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_uint32_nucleo_rx_signal_unit32_2_is_in_range(uint32_t value);

/**
 * Pack message DEMO_4_UINT16_NUCLEO_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_4_uint16_nucleo_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_4_uint16_nucleo_tx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_4_UINT16_NUCLEO_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_4_uint16_nucleo_tx_unpack(
    struct CanMsgs_demo_4_uint16_nucleo_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_tx_signal_unit16_4_is_in_range(uint16_t value);

/**
 * Pack message DEMO_4_UINT16_NUCLEO_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_4_uint16_nucleo_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_4_uint16_nucleo_rx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_4_UINT16_NUCLEO_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_4_uint16_nucleo_rx_unpack(
    struct CanMsgs_demo_4_uint16_nucleo_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_4_uint16_nucleo_rx_signal_unit16_4_is_in_range(uint16_t value);

/**
 * Pack message DEMO_8_UINT8_NUCLEO_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_8_uint8_nucleo_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_8_uint8_nucleo_tx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_8_UINT8_NUCLEO_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_8_uint8_nucleo_tx_unpack(
    struct CanMsgs_demo_8_uint8_nucleo_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_tx_signal_unit8_8_is_in_range(uint8_t value);

/**
 * Pack message DEMO_8_UINT8_NUCLEO_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_8_uint8_nucleo_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_8_uint8_nucleo_rx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_8_UINT8_NUCLEO_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_8_uint8_nucleo_rx_unpack(
    struct CanMsgs_demo_8_uint8_nucleo_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_8_uint8_nucleo_rx_signal_unit8_8_is_in_range(uint8_t value);

/**
 * Pack message DEMO_2_INT32_NUCLEO_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_2_int32_nucleo_tx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_2_int32_nucleo_tx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_2_INT32_NUCLEO_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_2_int32_nucleo_tx_unpack(
    struct CanMsgs_demo_2_int32_nucleo_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t CanMsgs_demo_2_int32_nucleo_tx_signal_int32_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_int32_nucleo_tx_signal_int32_1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_int32_nucleo_tx_signal_int32_1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_demo_2_int32_nucleo_tx_signal_int32_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_int32_nucleo_tx_signal_int32_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_int32_nucleo_tx_signal_int32_2_is_in_range(uint32_t value);

/**
 * Pack message DEMO_2_INT32_NUCLEO_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
ssize_t CanMsgs_demo_2_int32_nucleo_rx_pack(
    uint8_t *dst_p,
    const struct CanMsgs_demo_2_int32_nucleo_rx_t *src_p,
    size_t size);

/**
 * Unpack message DEMO_2_INT32_NUCLEO_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int CanMsgs_demo_2_int32_nucleo_rx_unpack(
    struct CanMsgs_demo_2_int32_nucleo_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t CanMsgs_demo_2_int32_nucleo_rx_signal_int32_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_int32_nucleo_rx_signal_int32_1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_int32_nucleo_rx_signal_int32_1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t CanMsgs_demo_2_int32_nucleo_rx_signal_int32_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double CanMsgs_demo_2_int32_nucleo_rx_signal_int32_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool CanMsgs_demo_2_int32_nucleo_rx_signal_int32_2_is_in_range(uint32_t value);

#endif
