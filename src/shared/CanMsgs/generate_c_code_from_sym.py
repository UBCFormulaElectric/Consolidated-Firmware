#!/usr/bin/python3

"""
This file contains all the functionality required to generate C code from 
our .sym file
"""

import os
from re import sub
from argparse import ArgumentParser
from cantools.database.can.c_source import generate
from cantools.database import load_file

# Get path of the current dir
PYTHON_EXECUTABLE_DIRECTORY = os.path.dirname(__file__)

def purge_timestamps_from_generated_code(code: str) -> str:
    """
    Purges timestamps from the generated C code so that we can diff it in CI to 
    check that the generated C code is up-to-date with the .sym file
    """
    # Ex. replace 
    # "* This file was generated by cantools version 32.4.0 Wed Jan  9 21:29:43 2019."
    # with:
    # "* This file was generated by cantools version 32.4.0"
    return sub(
        r'(This\sfile\swas\sgenerated\sby\scantools\sversion\s\d*\.\d*\.\d*\s).*',
        r'\1', code)

def generate_code_from_sym_file(database_name):
    """
    Generates C source code for the given .sym file 
    """
    dbase = load_file(database_name + ".sym", database_format="sym")

    filename_h = database_name + '.h'
    filename_c = database_name + '.c'

    header, source = generate(dbase, database_name, filename_h)
    header = purge_timestamps_from_generated_code(header)
    source = purge_timestamps_from_generated_code(source)

    with open(filename_h, 'w') as fout:
        fout.write(header)

    with open(filename_c, 'w') as fout:
        fout.write(source)

if __name__ == "__main__":
    sym_filename = "CanMsgs"
    os.chdir(PYTHON_EXECUTABLE_DIRECTORY)
    generate_code_from_sym_file(sym_filename)

