set(FPU_FLAGS
    -mcpu=cortex-m4
    -mfloat-abi=hard
    -mfpu=fpv4-sp-d16
)
set(COMPILER_FLAGS
    ${FPU_FLAGS}
    -mthumb
    -mthumb-interwork
    -ffunction-sections
    -fdata-sections
    -g3
    -fno-common
    -fmessage-length=0
    -Wall
    -Werror
    -Wextra
    -pedantic
    -specs=nosys.specs
    -specs=nano.specs
    -Wdouble-promotion
    -Wshadow
    -Wundef
    -fstack-usage
    -Wconversion
    -Wno-unused-variable
    -Wno-unused-parameter
)
set(COMPILER_DEFINES
    -D__weak=__attribute__\(\(weak\)\)
    -D__packed=__attribute__\(\(__packed__\)\)
    -DUSE_HAL_DRIVER
    -DARM_MATH_CM4
    -DARM_MATH_MATRIX_CHECK
    -DARM_MATH_ROUNDING
)
set(SYSTEMVIEW_ROOT ${CMAKE_SOURCE_DIR}/firmware/third_party/SEGGER_SystemView_Src)

function(compile_embedded_lib
    LIB_NAME
    LIB_SRCS
    LIB_INCLUDE_DIRS
    STM32_MCU
)
    add_library(${LIB_NAME} STATIC ${LIB_SRCS})

    # Suppress header file warnings for third-party IO code that are not meant
    # to be modified by marking them as system includes
    target_include_directories(${LIB_NAME} SYSTEM
        PUBLIC
        ${LIB_INCLUDE_DIRS}
    )
    
    # Suppress source file warnings for third-party IO code that are not meant to
    # be modified
    set_source_files_properties(
        ${LIB_SRCS}
        PROPERTIES COMPILE_FLAGS "-w"
    )

    target_compile_definitions(${LIB_NAME}
        PRIVATE
        ${COMPILER_DEFINES}
        -D${STM32_MCU}
    )
    target_compile_options(${LIB_NAME}
        PUBLIC
        ${COMPILER_FLAGS}
    )
    target_link_options(${LIB_NAME}
        PUBLIC
        ${FPU_FLAGS}
        -Wl,-gc-sections,--print-memory-usage
        --specs=nano.specs
    )
endfunction()

# Create the Arm binary executable that can be flashed to a board
# BOARD_NAME - The name of the board. This will be used to name the executable
# ARM_BINARY_SRCS - Source files for the Arm binary
# ARM_BINARY_INCLUDE_DIRS - Include directories for the Arm binary
# ARM_BINARY_THIRD_PARTY_SRCS - Third-party source files for the Arm binary
# that should have warnings suppressed
# ARM_BINARY_THIRD_PARTY_INCLUDE_DIRS - Third-party include directories for
# the Arm binary that should have
# warnings suppressed
# ARM_LINKER_SCRIPT - The Arm linker script for the board
# STM32_DEVICE_TYPE - The device name required for <stm32f3xx.h> to work
function(compile_arm_binary
    BOARD_NAME
    IOC_FILE
    ARM_BINARY_SRCS
    ARM_BINARY_INCLUDE_DIRS
    ARM_BINARY_THIRD_PARTY_SRCS
    ARM_BINARY_THIRD_PARTY_INCLUDE_DIRS
    ARM_LINKER_SCRIPT
    SELECTED_ARM_SHARED_BINARY_SRCS
    STM32_DEVICE_TYPE
)
    message("➕ Creating Arm Target for ${BOARD_NAME}")
    add_executable(${BOARD_NAME}.elf
        ${ARM_BINARY_SRCS}
        ${ARM_BINARY_THIRD_PARTY_SRCS}
        ${SELECTED_ARM_SHARED_BINARY_SRCS}
        ${SHARED_ARM_BINARY_X86_INCOMPATIBLE_THIRD_PARTY_SRCS}
        ${IOC_FILE}.md5
        ${GIT_HASH_AUTOGENERATED_SRC}
    )
    target_link_libraries(${BOARD_NAME}.elf "dim_stm32cube")
    add_dependencies(all_arm_binaries ${BOARD_NAME}.elf)
    # this makes it so that you don't have to include each file with a full path
    target_include_directories(${BOARD_NAME}.elf
        PRIVATE
        ${ARM_BINARY_INCLUDE_DIRS}
        ${SHARED_ARM_BINARY_INCLUDE_DIRS}
    )

    # Suppress header file warnings for third-party IO code that are not meant
    # to be modified by marking them as system includes
    target_include_directories(${BOARD_NAME}.elf SYSTEM
        PRIVATE
        ${ARM_BINARY_THIRD_PARTY_INCLUDE_DIRS}
        ${SHARED_ARM_BINARY_X86_INCOMPATIBLE_THIRD_PARTY_INCLUDE_DIRS}
    )

    # Suppress source file warnings for third-party IO code that are not meant to
    # be modified
    set_source_files_properties(
        ${ARM_BINARY_THIRD_PARTY_SRCS}
        ${SHARED_ARM_BINARY_X86_INCOMPATIBLE_THIRD_PARTY_SRCS}
        PROPERTIES COMPILE_FLAGS "-w")

    target_compile_definitions(${BOARD_NAME}.elf
        PRIVATE
        ${COMPILER_DEFINES}
        -D${STM32_DEVICE_TYPE}
    )
    target_compile_options(${BOARD_NAME}.elf
        PUBLIC
        ${COMPILER_FLAGS}
    )
    target_link_options(${BOARD_NAME}.elf
        PRIVATE
        ${FPU_FLAGS}
        -Wl,-Map=${CMAKE_CURRENT_BINARY_DIR}/${BOARD_NAME}.map
        -Wl,-gc-sections,--print-memory-usage
        -Wl,-T ${ARM_LINKER_SCRIPT}
        --specs=nano.specs
    )

    set(HEX_FILE "${BOARD_NAME}.hex")
    set(BIN_FILE "${BOARD_NAME}.bin")
    set(ASM_FILE "${BOARD_NAME}.asm")

    # objcoopy is used to create a binary, hex, and assembly file from the elf
    add_custom_command(TARGET ${BOARD_NAME}.elf POST_BUILD
        COMMAND ${CMAKE_OBJCOPY}
        -Oihex $<TARGET_FILE:${BOARD_NAME}.elf> $<TARGET_FILE_DIR:${BOARD_NAME}.elf>/${HEX_FILE}
        COMMAND ${CMAKE_OBJCOPY}
        -Obinary $<TARGET_FILE:${BOARD_NAME}.elf> $<TARGET_FILE_DIR:${BOARD_NAME}.elf>/${BIN_FILE}
        COMMAND ${CMAKE_OBJDUMP}
        -DS $<TARGET_FILE:${BOARD_NAME}.elf> > $<TARGET_FILE_DIR:${BOARD_NAME}.elf>/${ASM_FILE}
        COMMENT "
Building ${HEX_FILE}
Building ${BIN_FILE}
Building ${ASM_FILE}")
endfunction()

function(compile_embedded_binary
    BIN_NAME
    BIN_SRCS
    BIN_INCLUDE_DIRS
    STM32_MCU
    LINKER_SCRIPT
)
    message("➕ Creating Arm Target for ${BIN_NAME}")
    add_executable(${BIN_NAME} ${BIN_SRCS})

    # this makes it so that you don't have to include each file with a full path
    target_include_directories(${BIN_NAME}
        PRIVATE
        ${BIN_INCLUDE_DIRS}
    )

    target_compile_definitions(${BIN_NAME}
        PRIVATE
        ${COMPILER_DEFINES}
        -D${STM32_MCU}
    )
    target_compile_options(${BIN_NAME}
        PUBLIC
        ${COMPILER_FLAGS}
    )
    target_link_options(${BIN_NAME}
        PUBLIC
        ${FPU_FLAGS}
        -Wl,-Map=${CMAKE_CURRENT_BINARY_DIR}/${BIN_NAME}.map
        -Wl,-gc-sections,--print-memory-usage
        -Wl,-T ${LINKER_SCRIPT}
        --specs=nano.specs
    )

    set(HEX_FILE "${BIN_NAME}.hex")
    set(BIN_FILE "${BIN_NAME}.bin")
    set(ASM_FILE "${BIN_NAME}.asm")

    # objcoopy is used to create a binary, hex, and assembly file from the elf
    add_custom_command(TARGET ${BIN_NAME} POST_BUILD
        COMMAND ${CMAKE_OBJCOPY}
        -Oihex $<TARGET_FILE:${BIN_NAME}> $<TARGET_FILE_DIR:${BIN_NAME}>/${HEX_FILE}
        COMMAND ${CMAKE_OBJCOPY}
        -Obinary $<TARGET_FILE:${BIN_NAME}> $<TARGET_FILE_DIR:${BIN_NAME}>/${BIN_FILE}
        COMMAND ${CMAKE_OBJDUMP}
        -DS $<TARGET_FILE:${BIN_NAME}> > $<TARGET_FILE_DIR:${BIN_NAME}>/${ASM_FILE}
        COMMENT "
Building ${HEX_FILE}
Building ${BIN_FILE}
Building ${ASM_FILE}")
endfunction()

function(stm32cube_library
    HAL_LIB_NAME
    HAL_ROOT
    HAL_CONF_DIR
    HAL_SRCS
    SYSCALLS
    STM32_MCU
)
    set(DRIVERS_DIR "${HAL_ROOT}/Drivers")
    set(FREERTOS_DIR "${HAL_ROOT}/Middlewares/Third_Party/FreeRTOS/Source")

    set(STM32CUBE_INCLUDE_DIRS
        "${DRIVERS_DIR}/STM32F4xx_HAL_Driver/Inc"
        "${DRIVERS_DIR}/CMSIS/Include"
        "${DRIVERS_DIR}/STM32F4xx_HAL_Driver/Inc/Legacy"
        "${DRIVERS_DIR}/CMSIS/Device/ST/STM32F4xx/Include"
        "${FREERTOS_DIR}/include"
        "${FREERTOS_DIR}/CMSIS_RTOS_V2"
        "${FREERTOS_DIR}/portable/GCC/ARM_CM4F"
        "${HAL_CONF_DIR}"
        "${SYSTEMVIEW_ROOT}/SEGGER"
        "${SYSTEMVIEW_ROOT}/Config"
        "${SYSTEMVIEW_ROOT}/Sample/FreeRTOSV10"
    )
    
    set(STM32_HAL_SRCS)
    foreach(HAL_SRC ${HAL_SRCS})
        list(APPEND STM32_HAL_SRCS "${DRIVERS_DIR}/STM32F4xx_HAL_Driver/Src/${HAL_SRC}")
    endforeach()

    file(GLOB RTOS_SRCS
        "${FREERTOS_DIR}/*.c"
        "${FREERTOS_DIR}/CMSIS_RTOS_V2/*.c"
        "${FREERTOS_DIR}/portable/GCC/ARM_CM4F/*.c"
    )
    
    file(GLOB SYSTEMVIEW_SRCS 
        "${SYSTEMVIEW_ROOT}/SEGGER/*.c" 
        "${SYSTEMVIEW_ROOT}/SEGGER/*.S"
    )
    # We use ARM's embedded GCC compiler, so append the GCC-specific SysCalls.
    list(APPEND SYSTEMVIEW_SRCS "${SYSTEMVIEW_ROOT}/SEGGER/Syscalls/SEGGER_RTT_Syscalls_GCC.c")
    # Append the FreeRTOS patch to get SystemView to work with FreeRTOS. All of our STM32F412x boards use FreeRTOS V10. 
    # Note that the GSM currently has an STM32F302x MCU, which is limited to FreeRTOS V9, so SystemView is not supported
    # on the GSM.
    file(GLOB_RECURSE SYSTEMVIEW_FREERTOS_SRCS "${SYSTEMVIEW_ROOT}/Sample/FreeRTOSV10/*.c")
    list(APPEND SYSTEMVIEW_SRCS ${SYSTEMVIEW_FREERTOS_SRCS})

    set(STM32CUBE_SRCS ${STM32_HAL_SRCS} ${RTOS_SRCS} ${SYSTEMVIEW_SRCS} ${SYSCALLS})
    compile_embedded_lib(
        "${HAL_LIB_NAME}"
        "${STM32CUBE_SRCS}"
        "${STM32CUBE_INCLUDE_DIRS}"
        "${STM32_MCU}"
    )
endfunction()