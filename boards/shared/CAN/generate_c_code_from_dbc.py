"""
This file contains all the functionality required to generate C code from our
.dbc file
"""

import logging
import os
import sys
import argparse
from re import sub
from cantools.database.can.c_source import generate
from cantools.database.can.c_source import Message
from cantools.database import load_file

TX_HEADER_FMT = '''\
/**
 * @file  {header}
 * @brief Auto-generated CAN transmit library
 * @note  This file is auto-generated for {sender}. !!! Do not modify !!!
 */
// clang-format off
#ifndef CANMSGS_TX_H
#define CANMSGS_TX_H
/******************************************************************************
 * Includes
 ******************************************************************************/
#include <stdint.h>
#include "auto_generated/CanMsgs.h"
/******************************************************************************
 * Typedefs
 ******************************************************************************/
{typedefs}
/******************************************************************************
 * Function Prototypes
 ******************************************************************************/
{function_declarations}
#endif /* CANMSGS_TX_H */
'''

TX_SOURCE_FMT = '''\
/**
 * @brief This file is auto-generated for {sender}. !!! Do not modify !!!
 */
// clang-format off
/******************************************************************************
 * Includes
 ******************************************************************************/
#include <sched.h>
#include <string.h>
#include "auto_generated/{header}"
#include "SharedMacros.h"
#include "SharedCan.h"
#include "stm32f3xx_hal.h"
/******************************************************************************
 * Preprocessor Macros
 ******************************************************************************/
{defines}
/******************************************************************************
 * Module Variable Definitions
 ******************************************************************************/
{variables}
/******************************************************************************
 * Function Definitions
 ******************************************************************************/
{function_defs}
'''

PERIODIC_CANTX_TABEL_ENTRY_HELPER = '''\
/**
 * @brief Helper macro for initialize a single periodic CAN TX table entry.
 */
#define INIT_PERIODIC_CANTX_TABLE_ENTRY(FN_PTR, STDID, DLC, PERIOD, PAYLOAD) \\\

    {.pack_payload_fn=(pack_payload_fn_ptr)FN_PTR, .stdid=STDID, .dlc=DLC, .period=PERIOD, .payload=(const void*)PAYLOAD},
'''

TX_PACKING_FN_TYPEDEF = '''\
/**
 * @brief Function pointer for CAN payload packing function.
 * @note  This is supposed to match the function signature of the _pack
 *        functions generated by cantools. However, the second parameter of each
 *        _pack function is unique to each message struct but we must have one
 *        function pointer that works with every _pack function. The solution
 *        is to forcibly cast the type as void *.
 */
typedef int (*pack_payload_fn_ptr)(uint8_t *, const void *, size_t);
'''

PERIODIC_CANTX_TABLE_TYPEDEF_FMT = '''\
/**
 * @brief Table entry containing information about a single periodic CAN TX
 *        message 
 */
struct {tx_table_name}Entry
{{
    pack_payload_fn_ptr pack_payload_fn;
    uint32_t stdid;
    uint32_t dlc;
    uint32_t period;
    const void * payload;
}};
'''

PERIODIC_CANTX_TABLE_ENTRY_FMT = '''\
    INIT_PERIODIC_CANTX_TABLE_ENTRY({fn_ptr}, {stdid}U, {dlc}U, {period}U, {payload})
'''

PERIODIC_CANTX_TABLE_FMT = '''\
/**
 *@brief Table containing information about periodic CAN TX messages
 */
struct {tx_table_name}Entry {tx_table_name}[] =
{{
{members}}};
'''

PERIODIC_CANTX_PAYLOAD_STRUCT_TYPEDEF_FMT = '''\
    struct {database_name}_{message_name}_t {message_name};{warning}
'''

PERIODIC_CANTX_PAYLOADS_TYPEDEF_FMT = '''\
/** @brief Payloads of periodic CAN TX messages */
struct {tx_payloads_name}
{{
{members}}};
'''

PERIODIC_CANTX_PAYLOAD_INIT_FMT = '''\
    .{message_name} = {{ {init_value} }},{warning}
'''

PERIODIC_CANTX_PAYLOADS_FMT = '''\
/** @brief Payloads of periodic CAN TX messages */
struct {tx_payloads_name} {tx_payloads_name} =
{{
{members}}};
'''

PERIODIC_CANTX_TRANSMIT_FUNC_FMT = '''\
void {fn_prefix}_TransmitPeriodicMessages(void)
{{
    for (uint32_t i = 0; i < NUM_ELEMENTS_IN_ARRAY({tx_table_name}); i++)
    {{
        // Is it time to transmit this particular CAN message?
        if ((HAL_GetTick() % {tx_table_name}[i].period) == 0)
        {{
            // Prepare CAN message to transmit
            struct CanTxMsg tx_message;
            memset(&tx_message, 0, sizeof(tx_message));
            tx_message.std_id = PeriodicCanTxTable[i].stdid;
            tx_message.dlc = PeriodicCanTxTable[i].dlc;
            PeriodicCanTxTable[i].pack_payload_fn(
                &tx_message.data[0],
                PeriodicCanTxTable[i].payload,
                PeriodicCanTxTable[i].dlc);
            // Transmit the CAN payload with the appropriate ID and DLC 
            SharedCan_TransmitDataCan(&tx_message);
        }}
    }}
}}
'''

PERIODIC_CANTX_PAYLOADS_GETTER_FUNC_FMT = '''\
struct {tx_payloads_name} *{fn_prefix}_Get{tx_payloads_name}(void)
{{
    return &{tx_payloads_name};
}}
'''

NON_PERIODIC_CANTX_TRANSMIT_FUNC_DEFINITION_FMT = '''\
void {fn_prefix}_TransmitNonPeriodic_{tx_message_name_uppercase}(struct CanMsgs_{tx_message_name_snakecase}_t *payload)
{{
    struct CanTxMsg tx_msg;
    memset(&tx_msg, 0, sizeof(tx_msg));
    tx_msg.std_id = CANMSGS_{tx_message_name_uppercase}_FRAME_ID;
    tx_msg.dlc    = CANMSGS_{tx_message_name_uppercase}_LENGTH;
    memcpy(&tx_msg.data[0], &payload, CANMSGS_{tx_message_name_uppercase}_LENGTH); 
    CanMsgs_{tx_message_name_snakecase}_pack(
        &tx_msg.data[0],
        payload,
        CANMSGS_{tx_message_name_uppercase}_LENGTH);
    SharedCan_TransmitDataCan(&tx_msg);
}}
'''

NON_PERIODIC_CANTX_FORCE_TRANSMIT_FUNC_DEFINITION_FMT = '''\
void {fn_prefix}_ForceTransmitNonPeriodic_{tx_message_name_uppercase}(struct CanMsgs_{tx_message_name_snakecase}_t *payload)
{{
    struct CanTxMsg tx_msg;
    memset(&tx_msg, 0, sizeof(tx_msg));
    tx_msg.std_id = CANMSGS_{tx_message_name_uppercase}_FRAME_ID;
    tx_msg.dlc    = CANMSGS_{tx_message_name_uppercase}_LENGTH;
    memcpy(&tx_msg.data[0], &payload, CANMSGS_{tx_message_name_uppercase}_LENGTH); 
    CanMsgs_{tx_message_name_snakecase}_pack(
        &tx_msg.data[0],
        payload,
        CANMSGS_{tx_message_name_uppercase}_LENGTH);
    SharedCan_ForceEnqueueTxMessageAtFront(&tx_msg);
}}
'''

PERIODIC_CANTX_TRANSMIT_FUNC_DECLARATION_FMT = '''\
/**
 * @brief Transmits periodic CAN TX messages according to the cycle time
 *        specified in the DBC. This should be called in a 1kHz task.
 */
void {fn_prefix}_TransmitPeriodicMessages(void);
'''

PERIODIC_CANTX_PAYLOADS_GETTER_FUNC_DECLARATION_FMT = '''\
/**
 * @brief  Getter function for payloads of periodic CAN TX messages
 * @return Pointer to payloads for CAN TX messages
 */
struct {tx_payloads_name} *{fn_prefix}_Get{tx_payloads_name}(void);
'''

NON_PERIODIC_CANTX_TRANSMIT_FUNC_DECLARATION_FMT = '''\
/**
 * @brief Transmit the non-periodic CAN TX message {tx_message_name_uppercase}
 */
void {fn_prefix}_TransmitNonPeriodic_{tx_message_name_uppercase}(struct CanMsgs_{tx_message_name_snakecase}_t *payload);
'''

NON_PERIODIC_CANTX_FORCE_TRANSMIT_FUNC_DECLARATION_FMT = '''\
/**
 * @brief Push the non-periodic CAN TX message {tx_message_name_uppercase} to
 *        the front of CAN transmission queue
 */
void {fn_prefix}_ForceTransmitNonPeriodic_{tx_message_name_uppercase}(struct CanMsgs_{tx_message_name_snakecase}_t *payload);
'''

def purge_timestamps_from_generated_code(code: str) -> str:
    """
    Purges timestamps from the generated C code so that we can diff it in CI to
    check that the generated C code is up-to-date with the .dbc file
    """
    # Ex. replace:
    # "This file was generated by cantools version 32.4.0 Wed Jan  9 21:29:43 2019."
    # with:
    # "This file was generated by cantools"
    return sub(
        r'(This\sfile\swas\sgenerated\sby\scantools)\sversion\s\d*\.\d*\.\d*\s.*',
        r'\1', code)

def change_frame_id_capitalization(code: str) -> str:
    """
    Sets the symbol name in the FRAME_ID constant to lowercase for all CAN
    messages. This is done to allow us to reference both the constants and
    the associated function in C macros.
    """
    # Ex. replace:
    # "CANMSGS_SYMBOL1_FRAME_ID"
    # with:
    # "CANMSGS_symbol1_FRAME_ID"
    return sub(
        r'CANMSGS_(.*)_FRAME_ID',
        lambda match: r'CANMSGS_{}_FRAME_ID'.format(match.group(1).lower()),
        code)

def _generate_periodic_cantx_table_entries(database, database_name, sender, periodic_cantx_payloads_name):
    """
    Generates C source code for a single periodic CAN TX table entry
    """
    table_entries = []

    for message in [Message(message) for message in database.messages]:
        # The transmit table should only contain messages with a non-zero period
        if sender in message._message.senders and message.cycle_time > 0:
            table_entries.append(PERIODIC_CANTX_TABLE_ENTRY_FMT.format(
                fn_ptr=database_name + '_' + message.snake_name + '_pack',
                stdid=message.frame_id,
                dlc=message.length,
                period=message.cycle_time,
                payload='&' + periodic_cantx_payloads_name + '.' + message.snake_name))
    return ''.join(table_entries)

def _generate_periodic_cantx_table(database, database_name, sender, periodic_cantx_table_name, periodic_cantx_payloads_name):
    """
    Generates C source code for the periodic CAN TX table
    """
    return PERIODIC_CANTX_TABLE_FMT.format(
        tx_table_name=periodic_cantx_table_name,
        members=_generate_periodic_cantx_table_entries(database, database_name, sender, periodic_cantx_payloads_name))

def _generate_periodic_cantx_payloads_typedef_members(database, sender, database_name):
    """
    Generates C source code to for each struct member of the typedef struct containing
    payloads of the periodic CAN TX messages
    """
    payloads = []

    for message in [Message(message) for message in database.messages]:
        # The transmit table should only contain messages with a non-zero period
        if sender in message._message.senders and message.cycle_time > 0:
            warning = ' /* Warning: This DLC of this message is 0 so its struct contains only a dummy variable */' if message.length == 0 else ''
            payloads.append(PERIODIC_CANTX_PAYLOAD_STRUCT_TYPEDEF_FMT.format(
                database_name=database_name,
                message_name=message.snake_name,
                warning=warning))

    return ''.join(payloads)

def _generate_payloads_typedef(database, sender, database_name, periodic_cantx_payloads_name):
    """
    Generates C source code for a typedef struct containing payloads for all CAN TX messages
    """
    return PERIODIC_CANTX_PAYLOADS_TYPEDEF_FMT.format(
                members=_generate_periodic_cantx_payloads_typedef_members(database, sender, database_name),
                tx_payloads_name=periodic_cantx_payloads_name)

def _generate_tx_typedefs(database, sender, database_name, periodic_cantx_table_name, periodic_cantx_payloads_name):
    """
    Generates C soure code for CAN TX typedef declarations
    """
    typedefs = []
    typedefs.append(TX_PACKING_FN_TYPEDEF)
    typedefs.append(PERIODIC_CANTX_TABLE_TYPEDEF_FMT.format(tx_table_name=periodic_cantx_table_name))
    typedefs.append(_generate_payloads_typedef(database, sender, database_name, periodic_cantx_payloads_name))

    return '\n'.join(typedefs)

def _generate_periodic_cantx_payload_inits(database, sender):
    """
    Generates C source code to initialize each periodic CAN TX payload
    """
    payloads_init = []

    for message in [Message(message) for message in database.messages]:
        # The transmit table should only contain messages with a non-zero period
        if sender in message._message.senders and message.cycle_time > 0:
            warning = ' /* Warning: This DLC of this message is 0 so its struct contains only a dummy variable */' if message.length == 0 else ''
            payloads_init.append(PERIODIC_CANTX_PAYLOAD_INIT_FMT.format(
                message_name=message.snake_name,
                init_value=0,
                warning=warning))
    return ''.join(payloads_init)

def _generate_periodic_cantx_payloads(database, sender, periodic_cantx_payloads_name):
    """
    Generates C source code for a struct containing payloads of periodic CAN TX messages
    """
    return PERIODIC_CANTX_PAYLOADS_FMT.format(
        members=_generate_periodic_cantx_payload_inits(database, sender),
        tx_payloads_name=periodic_cantx_payloads_name)

def _generate_tx_variables(database, database_name, sender, periodic_cantx_table_name, periodic_cantx_payloads_name):
    """
    Generates C source code for file-scope variables
    """
    variables = []
    variables.append(_generate_periodic_cantx_payloads(database, sender, periodic_cantx_payloads_name))
    variables.append(_generate_periodic_cantx_table(database, database_name, sender, periodic_cantx_table_name, periodic_cantx_payloads_name))

    return '\n'.join(variables)

def _generate_tx_macros():
    """
    Generates C source code for helper macros
    """
    macros = []
    macros.append(PERIODIC_CANTX_TABEL_ENTRY_HELPER)

    return '\n'.join(macros)

def _generate_non_periodic_cantx_transmit_function_defs(database, sender, function_prefix):
    """
    Generates C source code for non-periodic CAN TX function definitions
    """
    non_periodic_transmit_func_defs = []

    for message in [Message(message) for message in database.messages]:
        # The transmit table should only contain messages with a zero period
        if sender in message._message.senders and message.cycle_time == 0:
            non_periodic_transmit_func_defs.append(NON_PERIODIC_CANTX_TRANSMIT_FUNC_DEFINITION_FMT.format(
                fn_prefix=function_prefix,
                tx_message_name_snakecase=message.snake_name,
                tx_message_name_uppercase=message.snake_name.upper()))
            non_periodic_transmit_func_defs.append(NON_PERIODIC_CANTX_FORCE_TRANSMIT_FUNC_DEFINITION_FMT.format(
                fn_prefix=function_prefix,
                tx_message_name_snakecase=message.snake_name,
                tx_message_name_uppercase=message.snake_name.upper()))

    return '\n'.join(non_periodic_transmit_func_defs)

def _generate_tx_function_defs(function_prefix, periodic_cantx_table_name, periodic_cantx_payloads_name, sender):
    """
    Generates C soure code for CAN TX function definitions
    """
    function_defs = []
    function_defs.append(PERIODIC_CANTX_TRANSMIT_FUNC_FMT.format(
        fn_prefix=function_prefix,
        tx_table_name=periodic_cantx_table_name))
    function_defs.append(PERIODIC_CANTX_PAYLOADS_GETTER_FUNC_FMT.format(
        fn_prefix=function_prefix,
        tx_payloads_name=periodic_cantx_payloads_name))
    function_defs.append(_generate_non_periodic_cantx_transmit_function_defs(database, sender, function_prefix))

    return '\n'.join(function_defs)

def _generate_tx_source(database, database_name, sender, header_name, function_prefix, periodic_cantx_table_name, periodic_cantx_payloads_name):
    """
    Generates C source code for CAN TX
    """
    tx_source = TX_SOURCE_FMT.format(
                    sender=sender,
                    header=header_name,
                    defines=_generate_tx_macros(),
                    variables=_generate_tx_variables(database, database_name, sender, periodic_cantx_table_name, periodic_cantx_payloads_name),
                    function_defs=_generate_tx_function_defs(function_prefix, periodic_cantx_table_name, periodic_cantx_payloads_name, sender))
    return tx_source

def _generate_non_periodic_cantx_transmit_function_declarations(database, sender, function_prefix):
    """
    Generates C source code for non-periodic CAN TX function declarations
    """
    non_periodic_transmit_func_declarations = []

    for message in [Message(message) for message in database.messages]:
        # The transmit table should only contain messages with a zero period
        if sender in message._message.senders and message.cycle_time == 0:
            non_periodic_transmit_func_declarations.append(
                NON_PERIODIC_CANTX_TRANSMIT_FUNC_DECLARATION_FMT.format(
                    fn_prefix=function_prefix,
                    tx_message_name_uppercase=message.snake_name.upper(),
                    tx_message_name_snakecase=message.snake_name))
            non_periodic_transmit_func_declarations.append(
                NON_PERIODIC_CANTX_FORCE_TRANSMIT_FUNC_DECLARATION_FMT.format(
                    fn_prefix=function_prefix,
                    tx_message_name_uppercase=message.snake_name.upper(),
                    tx_message_name_snakecase=message.snake_name))

    return ''.join(non_periodic_transmit_func_declarations)

def _generate_tx_function_declarations(function_prefix, periodic_cantx_table_name, periodic_cantx_payloads_name, sender):
    """
    Generates C source cod for CAN TX function declarations
    """
    function_declarations = []
    function_declarations.append(
        PERIODIC_CANTX_TRANSMIT_FUNC_DECLARATION_FMT.format(
            fn_prefix=function_prefix))
    function_declarations.append(
        PERIODIC_CANTX_PAYLOADS_GETTER_FUNC_DECLARATION_FMT.format(
            fn_prefix=function_prefix,
            tx_payloads_name=periodic_cantx_payloads_name))
    function_declarations.append(
        _generate_non_periodic_cantx_transmit_function_declarations(
            database,sender, function_prefix))

    return '\n'.join(function_declarations)

def _generate_tx_header(header_name, function_prefix, database, sender, database_name, periodic_cantx_table_name, periodic_cantx_payloads_name):
    """
    Generates C header files for CAN TX
    """
    return TX_HEADER_FMT.format(sender=sender,
                                header=header_name,
                                typedefs=_generate_tx_typedefs(database, sender, database_name, periodic_cantx_table_name, periodic_cantx_payloads_name),
                                function_declarations=_generate_tx_function_declarations(function_prefix, periodic_cantx_table_name, periodic_cantx_payloads_name, sender))

def generate_periodic_can_tx_code(database, database_name, board, source_dir, header_dir):
    """
    Generates C source code to transmit periodic CAN messages for the given board and .dbc file 
    """
    # Prepare name for generate files
    tx_filename   = 'App_' + database_name + 'Tx'
    tx_filename_c = tx_filename + '.c'
    tx_filename_h = tx_filename + '.h'
    periodic_tx_table_name = 'PeriodicCanTxTable'
    periodic_tx_payloads_name = 'PeriodicCanTxPayloads'

    # Generate output folders if they don't exist already 
    if not os.path.exists(source_dir):
        os.mkdir(source_dir)
    if not os.path.exists(header_dir):
        os.mkdir(header_dir)

    # Generate source file for transmitting periodic CAN messages
    tx_source = _generate_tx_source(database,
                                    database_name,
                                    board,
                                    tx_filename_h,
                                    tx_filename,
                                    periodic_tx_table_name,
                                    periodic_tx_payloads_name)

    with open(os.path.join(source_dir, tx_filename_c), 'w') as fout:
        fout.write(tx_source)

    # Generate header file for transmitting periodic CAN messages
    tx_header = _generate_tx_header(tx_filename_h,
                                    tx_filename,
                                    database,
                                    board,
                                    database_name,
                                    periodic_tx_table_name,
                                    periodic_tx_payloads_name)
    with open(os.path.join(header_dir, tx_filename_h), 'w') as fout:
        fout.write(tx_header)

def generate_cantools_c_code(database, database_name, source_dir, header_dir):
    """
    Generates C source code for the given .dbc file using cantools
    """
    # Prepare names for generate files
    filename_h = database_name + '.h'
    filename_c = database_name + '.c'

    # Generate C source code from cantools
    header, source, _, _ = generate(
            database,
            database_name,
            filename_h,
            filename_c,
            "",
            floating_point_numbers=True,
            bit_fields=True
    )

    # Remove timestamps from generated source code because
    # the timestamps would pollute git diff
    header = purge_timestamps_from_generated_code(header)
    source = purge_timestamps_from_generated_code(source)

    # Generate output folders if they don't exist already
    if not os.path.exists(source_dir):
        os.mkdir(source_dir)
    if not os.path.exists(header_dir):
        os.mkdir(header_dir)

    # Save generated code to disk
    with open(os.path.join(header_dir, filename_h), 'w') as fout:
        fout.write(header)

    with open(os.path.join(header_dir, filename_c), 'w') as fout:
        fout.write(source)

if __name__ == "__main__":
    # Parse arugments
    parser = argparse.ArgumentParser()
    valid_boards = ['FSM', 'DCM', 'PDM', 'BMS']
    parser.add_argument('board', help='Choose one of the following: ' + ' '.join(valid_boards))
    parser.add_argument('source_dir', help='Output directory of the generated source files for sending periodic CAN messages')
    parser.add_argument('header_dir', help='Output directory of the generated header files for sending periodic CAN messages')
    parser.add_argument('cantools_source_dir',help='Output directory of the source files generated by cantools')
    parser.add_argument('cantools_header_dir',help='Output directory of the header files generated by cantools')
    parser.add_argument('dbc', help='Path to the DBC file')
    args = parser.parse_args()
    if args.board not in valid_boards:
        print('Error: Invalid board name. Valid options: ' + ' '.join(valid_boards))
        sys.exit(1)

    # Configure logging level
    logging.basicConfig(level=logging.DEBUG)

    # DBC name without the file extension
    database_name = os.path.basename(args.dbc).replace('.dbc', '')

    # Load DBC in preparation of cantools
    database = load_file(args.dbc, database_format="dbc")

    # Generate code
    generate_periodic_can_tx_code(database, database_name, args.board, args.source_dir, args.header_dir)
    generate_cantools_c_code(database, database_name, args.cantools_source_dir, args.cantools_header_dir)
