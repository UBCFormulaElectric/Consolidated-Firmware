"""
This file contains all the functionality required to generate C code from our
.dbc file
"""
import logging
import sys
import argparse
from cantools_codegen import *
from canrx_codegen import *
from cantx_codegen import *

if __name__ == "__main__":
    # Parse arugments
    parser = argparse.ArgumentParser()
    valid_boards = ['FSM', 'DCM', 'PDM', 'BMS']
    parser.add_argument('board', help='Choose one of the following: ' + ' '.join(valid_boards))
    parser.add_argument('source_dir', help='Output directory of the generated source files for sending periodic CAN messages')
    parser.add_argument('header_dir', help='Output directory of the generated header files for sending periodic CAN messages')
    parser.add_argument('cantools_source_dir',help='Output directory of the source files generated by cantools')
    parser.add_argument('cantools_header_dir',help='Output directory of the header files generated by cantools')
    parser.add_argument('dbc', help='Path to the DBC file')
    args = parser.parse_args()
    if args.board not in valid_boards:
        print('Error: Invalid board name. Valid options: ' + ' '.join(valid_boards))
        sys.exit(1)

    # Configure logging level
    logging.basicConfig(level=logging.DEBUG)

    # DBC name without the file extension
    database_name = os.path.basename(args.dbc).replace('.dbc', '')

    # Load DBC in preparation of cantools
    database = load_file(args.dbc, database_format="dbc")
    for msg in list(msg for msg in map(Message, database.messages)):
        for signal in msg.signals:
            # We don't worry about non-periodic messages because those aren't
            # store in a global table and thus don't have race condition.
            if signal.type_length > 32 and msg.cycle_time != 0:
                raise Exception(
                    "[%s] -> [%s] must be less than 32-bit to ensure atomic access on our 32-bit microcontrollers!" % (msg.snake_name, signal.snake_name))

    # Generate CAN TX code
    cantx_source = CanTxSourceFileGenerator(database, os.path.join(args.source_dir, 'App_CanTx.c'), args.board, 'App_CanTx')
    cantx_source.generateSource()

    cantx_header = CanTxHeaderFileGenerator(database, os.path.join(args.header_dir, 'App_CanTx.h'), args.board, 'App_CanTx')
    cantx_header.generateHeader()

    # Generate CAN RX code
    canrx_source = CanRxSourceFileGenerator(database, os.path.join(args.source_dir, 'App_CanRx.c'), args.board, 'App_CanRx')
    canrx_source.generateSource()

    canrx_header = CanRxHeaderFileGenerator(database, os.path.join(args.header_dir, 'App_CanRx.h'), args.board, 'App_CanRx')
    canrx_header.generateHeader()

    generate_cantools_c_code(database, database_name, args.cantools_source_dir, args.cantools_header_dir)
