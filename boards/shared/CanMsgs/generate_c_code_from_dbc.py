"""
This file contains all the functionality required to generate C code from our
.dbc file
"""

import logging
import os
import sys
import argparse
from re import sub
from cantools.database.can.c_source import generate
from cantools.database.can.c_source import Message
from cantools.database import load_file

TX_HEADER_FMT = '''\
/**
 * @file  {header}
 * @brief Auto-generated CAN transmit library
 * @note  This file is auto-generated for {sender}. !!! Do not modify !!!
 */
// clang-format off
#ifndef CANMSGS_TX_H
#define CANMSGS_TX_H
/******************************************************************************
 * Includes
 ******************************************************************************/
#include <stdint.h>
#include <stdbool.h>
#include "CanMsgs.h"
/******************************************************************************
 * Typedefs
 ******************************************************************************/
{typedefs}
/******************************************************************************
 * Function Prototypes
 ******************************************************************************/
{function_declarations}
#endif /* CANMSGS_TX_H */
'''

TX_SOURCE_FMT = '''\
/**
 * @brief This file is auto-generated for {sender}. !!! Do not modify !!!
 */
// clang-format off
/******************************************************************************
 * Includes
 ******************************************************************************/
#include <sched.h>
#include "auto_generated/{header}"
#include <string.h>
#include "SharedMacros.h"
#include "SharedCan.h"
#include "stm32f3xx_hal.h"
/******************************************************************************
 * Preprocessor Macros
 ******************************************************************************/
{defines}
/******************************************************************************
 * Module Variable Definitions
 ******************************************************************************/
{variables}
/******************************************************************************
 * Function Definitions
 ******************************************************************************/
{function_defs}
'''

TX_TABEL_ENTRY_HELPER = '''\
/**
 * @brief Helper macro for initialize a single CAN transmit table entry.
 */
#define INIT_TABLE_ENTRY(FN_PTR, STDID, DLC, PERIOD, PAYLOAD) \\\

    {.pack_payload_fn=(pack_payload_fn_ptr)FN_PTR, .stdid=STDID, .dlc=DLC, .period=PERIOD, .payload=(const void*)PAYLOAD},
'''

TX_PACKING_FN_TYPEDEF = '''\
/**
 * @brief Function pointer for CAN payload packing function.
 * @note  This is supposed to match the function signature of the _pack
 *        functions generated by cantools. However, the second parameter of each
 *        _pack function is unique to each message struct but we must have one
 *        function pointer that works with every _pack function. The solution
 *        is to forcibly cast the type as void *.
 */
typedef int (*pack_payload_fn_ptr)(uint8_t *, const void *, size_t);
'''

TX_TABLE_TYPEDEF_FMT = '''\
/**
 * @brief CAN transmit message table entry with the necessary information to
 *        send a CAN message periodically.
 */
struct {tx_table_name}Entry
{{
    pack_payload_fn_ptr pack_payload_fn;
    uint32_t stdid;
    uint32_t dlc;
    uint32_t period;
    const void * payload;
}};
'''

TX_TABLE_ENTRY_FMT = '''\
    INIT_TABLE_ENTRY({fn_ptr}, {stdid}U, {dlc}U, {period}U, {payload})
'''

TX_TABLE_FMT = '''\
/**
 *@brief Table containing information about CAN messages that need to be
 *       transmitted at regular intervals
 */
struct {tx_table_name}Entry {tx_table_name}[] =
{{
{members}}};
'''

TX_PAYLOAD_STRUCT_TYPEDEF_FMT = '''\
    struct {database_name}_{message_name}_t {message_name};{warning}
'''

TX_PAYLOADS_TYPEDEF_FMT = '''\
/** @brief A collection of all CAN messages being transmitted from {sender}. */
struct {tx_payloads_name}
{{
{members}}};
'''

TX_PAYLOAD_INIT_FMT = '''\
    .{message_name} = {{ {init_value} }},{warning}
'''

TX_PAYLOADS_FMT = '''\
/** @brief All CAN periodic and non-periodic messages being transmitted */
struct {tx_payloads_name} {tx_payloads_name} =
{{
{members}}};
'''

TX_PERIODIC_SEND_FUNC_FMT = '''\
void {fn_prefix}_PeriodicTransmit(void)
{{
    for (uint32_t i = 0; i < NUM_ELEMENTS_IN_ARRAY({tx_table_name}); i++)
    {{
        // Is it time to transmit this particular CAN message?
        if ((HAL_GetTick() % {tx_table_name}[i].period) == 0)
        {{
            // Prepare CAN message to transmit
            struct CanTxMsg message;
            SHAREDCAN_PACK_CANTXMSG(message,
                                    CanTxPeriodicTable[i].stdid,
                                    CanTxPeriodicTable[i].dlc,
                                    CanTxPeriodicTable[i].payload,
                                    CanTxPeriodicTable[i].pack_payload_fn);
            // Transmit the CAN payload with the appropriate ID and DLC
            SharedCan_TransmitDataCan(message);
        }}
    }}
}}
'''

TX_TABLE_GETTER_FUNC_FMT = '''\
struct {tx_table_name}Entry *{fn_prefix}_Get{tx_table_name}(void)
{{
    return &{tx_table_name}[0];
}}
'''

TX_PAYLOADS_GETTER_FUNC_FMT = '''\
struct {tx_payloads_name} *{fn_prefix}_Get{tx_payloads_name}(void)
{{
    return &{tx_payloads_name};
}}
'''

TX_PERIODIC_SEND_FUNC_DECLARATION_FMT = '''\
/**
 * @brief Sends out periodic CAN messages according to the cycle time specified
 *        in the DBC. This should be called in a 1kHz task.
 */
void {fn_prefix}_PeriodicTransmit(void);
'''

TX_TABLE_GETTER_FUNC_DECLARATION_FMT ='''\
/**
 * @brief  Getter function for CAN transmit table
 * @return Pointer to CAN transmit table
 */
struct {tx_table_name}Entry *{fn_prefix}_Get{tx_table_name}(void);
'''

TX_PAYLOADS_GETTER_FUNC_DECLARATION_FMT = '''\
/**
 * @brief Getter function for CAN transmit payloads (Non-periodic and periodic)
 * @return Pointer to CAN transmit payloads
 */
struct {tx_payloads_name} *{fn_prefix}_Get{tx_payloads_name}(void);
'''

def purge_timestamps_from_generated_code(code: str) -> str:
    """
    Purges timestamps from the generated C code so that we can diff it in CI to
    check that the generated C code is up-to-date with the .dbc file
    """
    # Ex. replace:
    # "This file was generated by cantools version 32.4.0 Wed Jan  9 21:29:43 2019."
    # with:
    # "This file was generated by cantools"
    return sub(
        r'(This\sfile\swas\sgenerated\sby\scantools)\sversion\s\d*\.\d*\.\d*\s.*',
        r'\1', code)

def change_frame_id_capitalization(code: str) -> str:
    """
    Sets the symbol name in the FRAME_ID constant to lowercase for all CAN
    messages. This is done to allow us to reference both the constants and
    the associated function in C macros.
    """
    # Ex. replace:
    # "CANMSGS_SYMBOL1_FRAME_ID"
    # with:
    # "CANMSGS_symbol1_FRAME_ID"
    return sub(
        r'CANMSGS_(.*)_FRAME_ID',
        lambda match: r'CANMSGS_{}_FRAME_ID'.format(match.group(1).lower()),
        code)

def _generate_tx_can_table_entries(database, database_name, sender, payloads_name):
    """
    Generates C soure code for a single CAN TX table entry
    """
    messages = [Message(message) for message in database.messages]

    table_entries = []

    for message in messages:
        # The transmit table should only contain messages with a non-zero period
        if sender in message._message.senders and message.cycle_time > 0:
            table_entries.append(TX_TABLE_ENTRY_FMT.format(fn_ptr=database_name + '_' + message.snake_name + '_pack',
                                                           stdid=message.frame_id,
                                                           dlc=message.length,
                                                           period=message.cycle_time,
                                                           payload='&' + payloads_name + '.' + message.snake_name))
    return ''.join(table_entries)

def _generate_tx_can_table(database, database_name, sender, table_name, payloads_name):
    """
    Generates C soure code for CAN TX table
    """
    return TX_TABLE_FMT.format(tx_table_name=table_name,
                               members=_generate_tx_can_table_entries(database, database_name, sender, payloads_name))

def _generate_payloads_typedef_members(database, sender, database_name):
    """
    Generates C source code to for each struct member of the typedef struct containing
    payloads for all CAN TX messages
    """
    messages = [Message(message) for message in database.messages]

    payloads = []

    for message in messages:
        # Include periodic and non-periodic CAN messages being sent
        if sender in message._message.senders:
            warning = ' /* Warning: This DLC of this message is 0 so its struct contains only a dummy variable */' if message.length == 0 else ''
            payloads.append(TX_PAYLOAD_STRUCT_TYPEDEF_FMT.format(database_name=database_name,
                                                                 message_name=message.snake_name,
                                                                 warning=warning))

    return ''.join(payloads)

def _generate_payloads_typedef(database, sender, database_name, payloads_name):
    """
    Generates C source code for a typedef struct containing payloads for all CAN TX messages
    """
    return TX_PAYLOADS_TYPEDEF_FMT.format(sender=sender,
                                          members=_generate_payloads_typedef_members(database, sender, database_name),
                                          tx_payloads_name=payloads_name)

def _generate_tx_typedefs(database, sender, database_name, table_name, payloads_name):
    """
    Generates C soure code for CAN TX typedef declarations
    """
    typedefs = []
    typedefs.append(TX_PACKING_FN_TYPEDEF)
    typedefs.append(TX_TABLE_TYPEDEF_FMT.format(tx_table_name=table_name))
    typedefs.append(_generate_payloads_typedef(database, sender, database_name, payloads_name))

    return '\n'.join(typedefs)

def _generate_tx_payload_inits(database, sender):
    """
    Generates C source code to initialize each CAN TX payload
    """
    messages = [Message(message) for message in database.messages]

    payloads_init = []

    for message in messages:
        if sender in message._message.senders:
            warning = ' /* Warning: This DLC of this message is 0 so its struct contains only a dummy variable */' if message.length == 0 else ''
            payloads_init.append(TX_PAYLOAD_INIT_FMT.format(message_name=message.snake_name,
                                                            init_value=0,
                                                            warning=warning))
    return ''.join(payloads_init)

def _generate_tx_payloads(database, sender, payloads_name):
    """
    Generates C source code for a struct containing payloads for all CAN TX messages
    """
    return TX_PAYLOADS_FMT.format(members=_generate_tx_payload_inits(database, sender), tx_payloads_name=payloads_name)

def _generate_tx_variables(database, database_name, sender, table_name, payloads_name):
    """
    Generates C source code for file-scope variables
    """
    variables = []
    variables.append(_generate_tx_payloads(database, sender, payloads_name))
    variables.append(_generate_tx_can_table(database, database_name, sender, table_name, payloads_name))

    return '\n'.join(variables)

def _generate_tx_macros():
    """
    Generates C source code for helper macros
    """
    macros = []
    macros.append(TX_TABEL_ENTRY_HELPER)

    return '\n'.join(macros)

def _generate_tx_function_defs(function_prefix, table_name, payloads_name):
    """
    Generates C soure code for CAN TX function definitions
    """
    function_defs = []
    function_defs.append(TX_PERIODIC_SEND_FUNC_FMT.format(fn_prefix=function_prefix,
                                                          tx_table_name=table_name))
    function_defs.append(TX_TABLE_GETTER_FUNC_FMT.format(fn_prefix=function_prefix,
                                                         tx_table_name=table_name))
    function_defs.append(TX_PAYLOADS_GETTER_FUNC_FMT.format(fn_prefix=function_prefix,
                                                            tx_payloads_name=payloads_name))

    return '\n'.join(function_defs)

def _generate_tx_source(database, database_name, sender, header_name, function_prefix, table_name, payloads_name):
    """
    Generates C source code for CAN TX
    """
    tx_source = TX_SOURCE_FMT.format(sender=sender,
                                     header=header_name,
                                     defines=_generate_tx_macros(),
                                     variables=_generate_tx_variables(database, database_name, sender, table_name, payloads_name),
                                     function_defs=_generate_tx_function_defs(function_prefix, table_name, payloads_name))
    return tx_source

def _generate_tx_function_declarations(function_prefix, table_name, payloads_name):
    """
    Generates C source cod for CAN TX function declarations
    """
    function_declarations = []
    function_declarations.append(TX_PERIODIC_SEND_FUNC_DECLARATION_FMT.format(fn_prefix=function_prefix))
    function_declarations.append(TX_TABLE_GETTER_FUNC_DECLARATION_FMT.format(fn_prefix=function_prefix, tx_table_name=table_name))
    function_declarations.append(TX_PAYLOADS_GETTER_FUNC_DECLARATION_FMT.format(fn_prefix=function_prefix, tx_payloads_name=payloads_name))

    return '\n'.join(function_declarations)

def _generate_tx_header(header_name, function_prefix, database, sender, database_name, table_name, payloads_name):
    """
    Generates C header files for CAN TX
    """
    return TX_HEADER_FMT.format(sender=sender,
                                header=header_name,
                                typedefs=_generate_tx_typedefs(database, sender, database_name, table_name, payloads_name),
                                function_declarations=_generate_tx_function_declarations(function_prefix, table_name, payloads_name))

def generate_periodic_can_tx_code(database, database_name, board, source_dir, header_dir):
    """
    Generates C source code to transmit periodic CAN messages for the given board and .dbc file 
    """
    # Prepare name for generate files
    tx_filename   = 'App_' + database_name + 'Tx'
    tx_filename_c = tx_filename + '.c'
    tx_filename_h = tx_filename + '.h'
    tx_table_name = 'CanTxPeriodicTable'
    tx_payloads_name = 'CanTxPayloads'

    # Generate output folders if they don't exist already 
    if not os.path.exists(source_dir):
        os.mkdir(source_dir)
    if not os.path.exists(header_dir):
        os.mkdir(header_dir)

    # Generate source file for transmitting periodic CAN messages
    tx_source = _generate_tx_source(database,
                                    database_name,
                                    board,
                                    tx_filename_h,
                                    tx_filename,
                                    tx_table_name,
                                    tx_payloads_name)
    with open(os.path.join(source_dir, tx_filename_c), 'w') as fout:
        fout.write(tx_source)

    # Generate header file for transmitting periodic CAN messages
    tx_header = _generate_tx_header(tx_filename_h,
                                    tx_filename,
                                    database,
                                    board,
                                    database_name,
                                    tx_table_name,
                                    tx_payloads_name)
    with open(os.path.join(header_dir, tx_filename_h), 'w') as fout:
        fout.write(tx_header)

def generate_cantools_c_code(database, database_name, cantools_gen_dir):
    """
    Generates C source code for the given .dbc file using cantools
    """
    # Prepare names for generate files
    filename_h = database_name + '.h'
    filename_c = database_name + '.c'

    # Generate C source code from cantools
    header, source, _, _ = generate(
            database,
            database_name,
            filename_h,
            filename_c,
            "",
            floating_point_numbers=True,
            bit_fields=True
    )

    header = purge_timestamps_from_generated_code(header)
    source = purge_timestamps_from_generated_code(source)

    header = change_frame_id_capitalization(header)
    source = change_frame_id_capitalization(source)

    # Save generated source code to disk
    with open(os.path.join(cantools_gen_dir, filename_h), 'w') as fout:
        fout.write(header)

    with open(os.path.join(cantools_gen_dir, filename_c), 'w') as fout:
        fout.write(source)

if __name__ == "__main__":
    # Parse arugments
    parser = argparse.ArgumentParser()
    valid_boards = ['FSM', 'DCM', 'PDM', 'BMS']
    parser.add_argument('board', help='Choose one of the following: ' + ' '.join(valid_boards))
    parser.add_argument('source_dir', help='Output directory of the generated source files for sending periodic CAN messages')
    parser.add_argument('header_dir', help='Output directory of the generated header files for sending periodic CAN messages')
    parser.add_argument('cantools_gen_dir', help='Output directory of the files generated by cantools')
    parser.add_argument('dbc', help='Path to the DBC file')
    args = parser.parse_args()
    if args.board not in valid_boards:
        print('Error: Invalid board name. Valid options: ' + ' '.join(valid_boards))
        sys.exit(1)

    # Configure logging level
    logging.basicConfig(level=logging.DEBUG)

    # DBC name without the file extension
    database_name = os.path.basename(args.dbc).replace('.dbc', '')

    # Load DBC in preparation of cantools
    database = load_file(args.dbc, database_format="dbc")

    # Generate code
    generate_periodic_can_tx_code(database, database_name, args.board, args.source_dir, args.header_dir)
    generate_cantools_c_code(database, database_name, args.cantools_gen_dir)
