# commit_info_gen
Generates a header file and corresponding source file that exposes some info about the current commit:
- Short commit hash.
- If the commit is clean.

## Invocation
Invoke `src/generate_commit_info.py` with the `--output-header` and `--output-source` options to set the output paths.

For example,
```sh
python3 src/generate_commit_info.py --output-header ./examples/example_header.h --output-source ./examples/example_source.c
```

## Generated File
The generated header file exposes:
- `GIT_COMMIT_HASH`, eg. `0xe6dd7a7`
- `GIT_COMMIT_CLEAN`, which is `0` for dirty, and `1` for clean

A sample generated header file:

```h
#pragma once
#include <stdbool.h>

#define GIT_COMMIT_HASH 0x71a529a
#define GIT_COMMIT_CLEAN false
```

The generated source file looks like:

```c
#include "example_header.h"
/* 
  This file is intentionally empty,
  it only exists to tell cmake to scan 
*/

// to make pedantic compilation happy (avoid empty translation unit error)
extern int commit_info_happy_pedantic_compilation;
```

## Why do we have an empty source file?
The current CMake configuration requires us to have an autogenerated source for every header. Pedantic compillation doesn't like empty source files, so we add `extern int commit_info_happy_pedantic_compilation;` to make the compiler happy :D.

## Dummy Data
Since commit_info_Gen is not a critical component, we do not want it to block compilation under any circumstance. Because of this, under any error related to git, or in the case that faulty data was produced internally, dummy data is released instead (`0` on hash, `0` on clean).

## Implementation
- `jinja2` for templating.
- `GitPython` for interfacing with git through Python.