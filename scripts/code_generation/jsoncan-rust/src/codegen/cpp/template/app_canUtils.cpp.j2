/**
 * @note This file is auto-generated. Do not modify!
 */
// clang-format off

#include <span>
#include "app_canUtils.hpp"

namespace app::can_utils {
/* ------------------ Static Packing/Unpacking Functions ------------------ */

/**
 * Shift input left and apply mask, for packing.
 */
static uint8_t packShiftLeft(const uint32_t input, const uint8_t shift, const uint8_t mask)
{
    return static_cast<uint8_t>(static_cast<uint8_t>(input << shift) & static_cast<uint8_t>(mask));
}

/**
 * Shift input right and apply mask, for packing.
 */
static uint8_t packShiftRight(const uint32_t input, const uint8_t shift, const uint8_t mask)
{
    return static_cast<uint8_t>(static_cast<uint8_t>(input >> shift) & static_cast<uint8_t>(mask));
}

/**
 * Apply mask, then shift input left by shift bits, for unpacking.
 */
static uint32_t unpackShiftLeft(const uint8_t input, const uint8_t shift, const uint8_t mask)
{
    return static_cast<uint32_t>(static_cast<uint32_t>(input & mask) << shift);
}

/**
 * Apply mask, then shift input left by shift bits, for unpacking.
 */
static uint32_t unpackShiftRight(const uint8_t input, const uint8_t shift, const uint8_t mask)
{
    return static_cast<uint32_t>(static_cast<uint32_t>(input & mask) >> shift);
}


/* ----------------------- Encoding/Decoding Macros ----------------------- */

/**
 * Encode real signal value to payload representation, w/ scale and offset (unsigned).
 */
template<typename T>
static T CAN_ENCODE(const auto input, const double scale, const double offset)
{
    return static_cast<T>((static_cast<double>(input) - offset) / scale);
}

/**
 * Encode real signal value to payload representation, w/ scale and offset (signed).
 */
static int32_t CAN_SIGNED_ENCODE(const double input, const double scale, const double offset)
{
    return static_cast<int32_t>((input - offset) / scale);
}

/**
 * Decode payload representation of signal to signal value, w/ scale and offset.
 */
template<typename T>
static T CAN_DECODE(const float input, const float scale, const float offset)
{
    return static_cast<T>(input * scale + offset);
}

/**
 * Interpret input as a signed number of length bits via 2s complement.
 */
static int SIGNED_DECODE(const uint32_t input, const uint32_t bits, const uint32_t mask)
{
    return static_cast<int>((input & (1 << (bits - 1))) ? -((~input & mask) + 1) : input);
}

/* ------------------------- Function Definitions ------------------------- */

{% set scale_macro = "CANSIG_{}_{}_SCALE" %}
{% set offset_macro = "CANSIG_{}_{}_OFFSET" %}

{% for msg in messages -%}
{% set msg_big_name =  msg.screaming_snake_name() %}
// pack function for {{ msg.name }}
void {{ msg.name }}_Signals::pack(const std::span<uint8_t> out_data) const
{
    // Pack message {{ msg.name }}.
    // {{ signal_placement_comment(msg) }}
    {% if msg.signals.len() == 0 %}
    // No signals in {{ msg.name }}, so no pack function.
    out_data[0] = _placeholder;
    {% else %}
    {% for signal in msg.signals %}
    {%- decl raw_type -%}
    {%-if signal.signed -%}
    {%- let raw_type = "int32_t" -%}
    {%- else -%}
    {%- let raw_type = "uint32_t" -%}
    {%- endif -%}
    {%- decl decord_macro -%}
    {%- if signal.signed -%}
        {%- let decord_macro = "CAN_SIGNED_ENCODE" -%}
    {%- else -%}
        {%- let decord_macro = "CAN_ENCODE" -%}
    {%- endif -%}
    // Pack {{ signal.bits }}-bit signal {{ signal.name }} into payload at [ bit {{ signal.start_bit }} to bit {{ signal.start_bit + signal.bits }} ).
    const {{ signal.datatype() }} {{ signal.name }}_val = {{ signal.name }}_value;
    const auto {{ signal.name }}_raw = {{ decord_macro }}<{{ raw_type }}>({{ signal.name }}_val, {{ signal.scale_macro() }}, {{ signal.offset_macro() }});
    {% for iteration in iterations(signal) -%}
    {%- decl packShift -%}
    {%- if iteration.shift >= 0 -%}
    {%- let packShift = "packShiftRight" -%}
    {%- else -%}
    {%- let packShift = "packShiftLeft" -%}
    {%- endif -%}
    out_data[{{ iteration.starting_byte }}] |= {{ packShift }}({{ signal.name }}_raw, {{ iteration.shift }}, {{ iteration.mask_text }});   // Packs bits {{ iteration.comment_data }} of byte {{ iteration.starting_byte }}
    {% endfor %}
    {% endfor %}
    {%- endif %}
}
{% endfor %}

{% for msg in messages -%}
{% if msg.signals.len() == 0 %}
// No signals in {{ msg.name }}, so no unpack function.
{% else %}
{% set msg_big_name =  msg.screaming_snake_name() %}
{{ msg.name }}_Signals::{{ msg.name }}_Signals(const std::span<const uint8_t> data)
{
    // Unpack message {{ msg.name }}.
    // {{ signal_placement_comment(msg) }}

    {% for signal in msg.signals %}
    {%- set signal_big_name =  signal.screaming_snake_name() -%}
    uint32_t {{ signal.name }}_raw = 0; // Temporary raw variable for {{ signal.name }}
    {% for iteration in iterations(signal) -%}
    {%- decl unpackShift -%}
    {%- if iteration.shift >= 0 -%}
    {%- let unpackShift = "unpackShiftRight" -%}
    {%- else -%}
    {%- let unpackShift = "unpackShiftLeft" -%}
    {%- endif -%}
    {{ signal.name }}_raw |= {{ unpackShift }}(data[{{ iteration.starting_byte }}], {{ iteration.shift.abs() }}, {{ iteration.mask_text }}); // Unpacks bits {{ iteration.comment_data }} from byte {{ iteration.starting_byte }}
    {% endfor -%}
    {%- if signal.signed -%}
    const int {{ signal.name }}_signed = SIGNED_DECODE({{ signal.name }}_raw, {{ signal.bits }}, {{ max_uint_for_bits(signal.bits) }});
    {{ signal.name }}_value = CAN_DECODE<{{ signal.datatype() }}>({{ signal.name }}_signed, {{ signal.scale_macro() }}, {{ signal.offset_macro() }});
    {%- else -%}
    {{ signal.name }}_value = CAN_DECODE<{{ signal.datatype() }}>({{ signal.name }}_raw, {{ signal.scale_macro() }}, {{ signal.offset_macro() }});
    {% endif %}
    {%- endfor %}
}
{%- endfor %}
{% endif %}
}